
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoGuiMLTextCtrl : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coGuiMLTextCtrl(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoGuiMLTextCtrl))]
    public class coGuiMLTextCtrl: coGuiControl
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiMLTextCtrl(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiMLTextCtrl(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiMLTextCtrl(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coGuiMLTextCtrl ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coGuiMLTextCtrl ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coGuiMLTextCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiMLTextCtrl(string ts)
            {
            return new coGuiMLTextCtrl(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coGuiMLTextCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiMLTextCtrl(int ts)
            {
            return new coGuiMLTextCtrl(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coGuiMLTextCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiMLTextCtrl(uint ts)
            {
            return new coGuiMLTextCtrl(ts);
            }
/// <summary>
/// If true, the control will allow characters to have unique colors.
/// </summary>
public bool allowColorChars
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".allowColorChars").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".allowColorChars", value.AsString());
          }
       }
/// <summary>
/// If the text will not fit in the control, the deniedSound is played.
/// </summary>
public coSFXTrack deniedSound
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".deniedSound");
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".deniedSound", value.ToString());
          }
       }
/// <summary>
/// The number of blank pixels to place between each line.\n
/// </summary>
public int lineSpacing
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".lineSpacing").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".lineSpacing", value.AsString());
          }
       }
/// <summary>
/// Maximum number of characters that the control will display.
/// </summary>
public int maxChars
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".maxChars").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".maxChars", value.AsString());
          }
       }
/// <summary>
/// Text to display in this control.
/// </summary>
public String text
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".text").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".text", value.AsString());
          }
       }
/// <summary>
/// If true, the mouse cursor will turn into a hand cursor while over a link in the text.\n																							 This is dependant on the markup language used by the GuiMLTextCtrl\n
/// </summary>
public bool useURLMouseCursor
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".useURLMouseCursor").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".useURLMouseCursor", value.AsString());
          }
       }
/// <summary>
/// @brief Appends the text in the control with additional text. Also .
///    @param text New text to append to the existing text.
///    @param reformat If true, the control will also be visually reset.
///    @tsexample
///    // Define new text to add
///    %text = \"New Text to Add\";
///    // Set reformat boolean
///    %reformat = \"true\";
///    // Inform the control to add the new text
///    %thisGuiMLTextCtrl.addText(%text,%reformat);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void addText(string text, bool reformat){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_addText(_mSimObjectId, text, reformat);
}
/// <summary>
/// @brief Forces the text control to reflow the text after new text is added, possibly resizing the control.
///    @tsexample
///    // Define new text to add
///    %newText = \"BACON!\";
///    // Add the new text to the control
///    %thisGuiMLTextCtrl.addText(%newText);
///    // Inform the GuiMLTextCtrl object to force a reflow to ensure the added text fits properly.
///    %thisGuiMLTextCtrl.forceReflow();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void forceReflow(){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_forceReflow(_mSimObjectId);
}
/// <summary>
/// @brief Returns the text from the control, including TorqueML characters.
///    @tsexample
///    // Get the text displayed in the control
///    %controlText = %thisGuiMLTextCtrl.getText();
///    @endtsexample
///    @return Text string displayed in the control, including any TorqueML characters.
///    @see GuiControl)
/// 
/// </summary>
public  string getText(){
return TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_getText(_mSimObjectId);
}
/// <summary>
/// @brief Scroll to the bottom of the text.
///    @tsexample
///    // Inform GuiMLTextCtrl object to scroll to its bottom
///    %thisGuiMLTextCtrl.scrollToBottom();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void scrollToBottom(){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_scrollToBottom(_mSimObjectId);
}
/// <summary>
/// @brief Scroll down to a specified tag.
///    Detailed description
///    @param tagID TagID to scroll the control to
///    @tsexample
///    // Define the TagID we want to scroll the control to
///    %tagId = \"4\";
///    // Inform the GuiMLTextCtrl to scroll to the defined TagID
///    %thisGuiMLTextCtrl.scrollToTag(%tagId);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void scrollToTag(int tagID){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_scrollToTag(_mSimObjectId, tagID);
}
/// <summary>
/// @brief Scroll to the top of the text.
///    @tsexample
///    // Inform GuiMLTextCtrl object to scroll to its top
///    %thisGuiMLTextCtrl.scrollToTop();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void scrollToTop(int param1, int param2){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_scrollToTop(_mSimObjectId, param1, param2);
}
/// <summary>
/// @brief Sets the alpha value of the control.
///    @param alphaVal n - 1.0 floating value for the alpha
///    @tsexample
///    // Define the alphe value
///    %alphaVal = \"0.5\";
///    // Inform the control to update its alpha value.
///    %thisGuiMLTextCtrl.setAlpha(%alphaVal);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void setAlpha(float alphaVal){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_setAlpha(_mSimObjectId, alphaVal);
}
/// <summary>
/// @brief Change the text cursor's position to a new defined offset within the text in the control.
///    @param newPos Offset to place cursor.
///    @tsexample
///    // Define cursor offset position
///    %position = \"23\";
///    // Inform the GuiMLTextCtrl object to move the cursor to the new position.
///    %thisGuiMLTextCtrl.setCursorPosition(%position);
///    @endtsexample
///    @return Returns true if the cursor position moved, or false if the position was not changed.
///    @see GuiControl)
/// 
/// </summary>
public  bool setCursorPosition(int newPos){
return TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_setCursorPosition(_mSimObjectId, newPos);
}
/// <summary>
/// @brief Set the text contained in the control.
///    @param text The text to display in the control.
///    @tsexample
///    // Define the text to display
///    %text = \"Nifty Control Text\";
///    // Set the text displayed within the control
///    %thisGuiMLTextCtrl.setText(%text);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>
public  void setText(string text){
TorqueScriptTemplate.m_ts.fnGuiMLTextCtrl_setText(_mSimObjectId, text);
}
}}
