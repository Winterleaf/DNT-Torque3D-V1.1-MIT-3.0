
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoSceneObject : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coSceneObject(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoSceneObject))]
    public class coSceneObject: coNetObject
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSceneObject(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSceneObject(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSceneObject(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coSceneObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coSceneObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coSceneObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSceneObject(string ts)
            {
            return new coSceneObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coSceneObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSceneObject(int ts)
            {
            return new coSceneObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coSceneObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSceneObject(uint ts)
            {
            return new coSceneObject(ts);
            }
/// <summary>
/// Controls client-side rendering of the object.\n     @see isRenderable()\n 
/// </summary>
public bool isRenderEnabled
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".isRenderEnabled").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".isRenderEnabled", value.AsString());
          }
       }
/// <summary>
/// Determines if the object may be selected from wihin the Tools.\n     @see isSelectable()\n 
/// </summary>
public bool isSelectionEnabled
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".isSelectionEnabled").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".isSelectionEnabled", value.AsString());
          }
       }
/// <summary>
/// Node we are mounted to. 
/// </summary>
public int mountNode
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".mountNode").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".mountNode", value.AsString());
          }
       }
/// <summary>
/// @brief PersistentID of object we are mounted to.\n\n     Unlike the SimObjectID that is determined at run time, the PersistentID of an object is saved with the level/mission and      may be used to form a link between objects. 
/// </summary>
public int mountPID
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".mountPID").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".mountPID", value.AsString());
          }
       }
private TransformF _mountPos = null;
/// <summary>
/// Position we are mounted at ( object space of our mount object ). 
/// </summary>
public TransformF mountPos
       {
       get
          {
          if (_mountPos!=null)
              _mountPos.DetachAllEvents();
           _mountPos = dnTorque.self.GetVar(_mSimObjectId + ".mountPos").AsTransformF();
          _mountPos.OnChangeNotification +=_mountPos_OnChangeNotification;
          return _mountPos;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".mountPos", value.AsString());
          }
       }
void _mountPos_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".mountPos", e.NewValue);
       }
private TransformF _mountRot = null;
/// <summary>
/// Rotation we are mounted at ( object space of our mount object ). 
/// </summary>
public TransformF mountRot
       {
       get
          {
          if (_mountRot!=null)
              _mountRot.DetachAllEvents();
           _mountRot = dnTorque.self.GetVar(_mSimObjectId + ".mountRot").AsTransformF();
          _mountRot.OnChangeNotification +=_mountRot_OnChangeNotification;
          return _mountRot;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".mountRot", value.AsString());
          }
       }
void _mountRot_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".mountRot", e.NewValue);
       }
private TransformF _position = null;
/// <summary>
/// Object world position. 
/// </summary>
public TransformF position
       {
       get
          {
          if (_position!=null)
              _position.DetachAllEvents();
           _position = dnTorque.self.GetVar(_mSimObjectId + ".position").AsTransformF();
          _position.OnChangeNotification +=_position_OnChangeNotification;
          return _position;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".position", value.AsString());
          }
       }
void _position_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".position", e.NewValue);
       }
private TransformF _rotation = null;
/// <summary>
/// Object world orientation. 
/// </summary>
public TransformF rotation
       {
       get
          {
          if (_rotation!=null)
              _rotation.DetachAllEvents();
           _rotation = dnTorque.self.GetVar(_mSimObjectId + ".rotation").AsTransformF();
          _rotation.OnChangeNotification +=_rotation_OnChangeNotification;
          return _rotation;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".rotation", value.AsString());
          }
       }
void _rotation_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".rotation", e.NewValue);
       }
private Point3F _scale = null;
/// <summary>
/// Object world scale. 
/// </summary>
public Point3F scale
       {
       get
          {
          if (_scale!=null)
              _scale.DetachAllEvents();
           _scale = dnTorque.self.GetVar(_mSimObjectId + ".scale").AsPoint3F();
          _scale.OnChangeNotification +=_scale_OnChangeNotification;
          return _scale;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".scale", value.AsString());
          }
       }
void _scale_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".scale", e.NewValue);
       }
/// <summary>
/// Get Euler rotation of this object.
///    @return the orientation of the object in the form of rotations around the 
///    X, Y and Z axes in degrees. )
/// 
/// </summary>
public  Point3F getEulerRotation(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getEulerRotation(_mSimObjectId));
}
/// <summary>
/// Get the direction this object is facing.
///    @return a vector indicating the direction this object is facing.
///    @note This is the object's y axis. )
/// 
/// </summary>
public  Point3F getForwardVector(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getForwardVector(_mSimObjectId));
}
/// <summary>
/// Get the object's inverse transform.
///    @return the inverse transform of the object )
/// 
/// </summary>
public  TransformF getInverseTransform(){
return new TransformF ( TorqueScriptTemplate.m_ts.fnSceneObject_getInverseTransform(_mSimObjectId));
}
/// <summary>
/// Get the object mounted at a particular slot.
///    @param slot mount slot index to query
///    @return ID of the object mounted in the slot, or 0 if no object. )
/// 
/// </summary>
public  int getMountedObject(int slot){
return TorqueScriptTemplate.m_ts.fnSceneObject_getMountedObject(_mSimObjectId, slot);
}
/// <summary>
/// Get the number of objects mounted to us.
///    @return the number of mounted objects. )
/// 
/// </summary>
public  int getMountedObjectCount(){
return TorqueScriptTemplate.m_ts.fnSceneObject_getMountedObjectCount(_mSimObjectId);
}
/// <summary>
/// @brief Get the mount node index of the object mounted at our given slot.
///    @param slot mount slot index to query
///    @return index of the mount node used by the object mounted in this slot. )
/// 
/// </summary>
public  int getMountedObjectNode(int slot){
return TorqueScriptTemplate.m_ts.fnSceneObject_getMountedObjectNode(_mSimObjectId, slot);
}
/// <summary>
/// @brief Get the object mounted at our given node index.
///    @param node mount node index to query
///    @return ID of the first object mounted at the node, or 0 if none found. )
/// 
/// </summary>
public  int getMountNodeObject(int node){
return TorqueScriptTemplate.m_ts.fnSceneObject_getMountNodeObject(_mSimObjectId, node);
}
/// <summary>
/// Get the object's bounding box (relative to the object's origin).
///    @return six fields, two Point3Fs, containing the min and max points of the 
///    objectbox. )
/// 
/// </summary>
public  Box3F getObjectBox(){
return new Box3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getObjectBox(_mSimObjectId));
}
/// <summary>
/// @brief Get the object we are mounted to.
///    @return the SimObjectID of the object we're mounted to, or 0 if not mounted. )
/// 
/// </summary>
public  int getObjectMount(){
return TorqueScriptTemplate.m_ts.fnSceneObject_getObjectMount(_mSimObjectId);
}
/// <summary>
/// Get the object's world position.
///    @return the current world position of the object )
/// 
/// </summary>
public  Point3F getPosition(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getPosition(_mSimObjectId));
}
/// <summary>
/// Get the right vector of the object.
///    @return a vector indicating the right direction of this object.
///    @note This is the object's x axis. )
/// 
/// </summary>
public  Point3F getRightVector(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getRightVector(_mSimObjectId));
}
/// <summary>
/// Get the object's scale.
///    @return object scale as a Point3F )
/// 
/// </summary>
public  Point3F getScale(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getScale(_mSimObjectId));
}
/// <summary>
/// Get the object's transform.
///    @return the current transform of the object )
/// 
/// </summary>
public  TransformF getTransform(){
return new TransformF ( TorqueScriptTemplate.m_ts.fnSceneObject_getTransform(_mSimObjectId));
}
/// <summary>
/// Return the type mask for this object.
///    @return The numeric type mask for the object. )
/// 
/// </summary>
public  int getType(){
return TorqueScriptTemplate.m_ts.fnSceneObject_getType(_mSimObjectId);
}
/// <summary>
/// Get the up vector of the object.
///    @return a vector indicating the up direction of this object.
///    @note This is the object's z axis. )
/// 
/// </summary>
public  Point3F getUpVector(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getUpVector(_mSimObjectId));
}
/// <summary>
/// Get the object's world bounding box.
///    @return six fields, two Point3Fs, containing the min and max points of the 
///    worldbox. )
/// 
/// </summary>
public  Box3F getWorldBox(){
return new Box3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getWorldBox(_mSimObjectId));
}
/// <summary>
/// Get the center of the object's world bounding box.
///    @return the center of the world bounding box for this object. )
/// 
/// </summary>
public  Point3F getWorldBoxCenter(){
return new Point3F ( TorqueScriptTemplate.m_ts.fnSceneObject_getWorldBoxCenter(_mSimObjectId));
}
/// <summary>
/// Check if this object has a global bounds set.
///    If global bounds are set to be true, then the object is assumed to have an 
///    infinitely large bounding box for collision and rendering purposes.
///    @return true if the object has a global bounds. )
/// 
/// </summary>
public  bool isGlobalBounds(){
return TorqueScriptTemplate.m_ts.fnSceneObject_isGlobalBounds(_mSimObjectId);
}
/// <summary>
/// @brief Check if we are mounted to another object.
///    @return true if mounted to another object, false if not mounted. )
/// 
/// </summary>
public  bool isMounted(){
return TorqueScriptTemplate.m_ts.fnSceneObject_isMounted(_mSimObjectId);
}
/// <summary>
/// @brief Mount objB to this object at the desired slot with optional transform.
/// 
///    @param objB  Object to mount onto us
///    @param slot  Mount slot ID
///    @param txfm (optional) mount offset transform
///    @return true if successful, false if failed (objB is not valid) )
/// 
/// </summary>
public  bool mountObject(string objB, int slot, TransformF txfm){
return TorqueScriptTemplate.m_ts.fnSceneObject_mountObject(_mSimObjectId, objB, slot, txfm.AsString());
}
/// <summary>
/// Set the object's scale.
///    @param scale object scale to set )
/// 
/// </summary>
public  void setScale(Point3F scale){
TorqueScriptTemplate.m_ts.fnSceneObject_setScale(_mSimObjectId, scale.AsString());
}
/// <summary>
/// Set the object's transform (orientation and position).
///    @param txfm object transform to set )
/// 
/// </summary>
public  void setTransform(TransformF txfm){
TorqueScriptTemplate.m_ts.fnSceneObject_setTransform(_mSimObjectId, txfm.AsString());
}
/// <summary>
/// Unmount us from the currently mounted object if any. )
/// 
/// </summary>
public  void unmount(){
TorqueScriptTemplate.m_ts.fnSceneObject_unmount(_mSimObjectId);
}
/// <summary>
/// @brief Unmount an object from ourselves.
/// 
///    @param target object to unmount
///    @return true if successful, false if failed )
/// 
/// </summary>
public  bool unmountObject(string target){
return TorqueScriptTemplate.m_ts.fnSceneObject_unmountObject(_mSimObjectId, target);
}
}}
