
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoWorldEditor : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coWorldEditor(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoWorldEditor))]
    public class coWorldEditor: coEditTSCtrl
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coWorldEditor(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coWorldEditor(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coWorldEditor(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coWorldEditor ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coWorldEditor ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coWorldEditor ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coWorldEditor(string ts)
            {
            return new coWorldEditor(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coWorldEditor ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coWorldEditor(int ts)
            {
            return new coWorldEditor(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coWorldEditor ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coWorldEditor(uint ts)
            {
            return new coWorldEditor(ts);
            }
/// <summary>
/// 
/// </summary>
public bool boundingBoxCollision
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".boundingBoxCollision").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".boundingBoxCollision", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public String defaultHandle
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".defaultHandle").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".defaultHandle", value.AsString());
          }
       }
private ColorI _dragRectColor = null;
/// <summary>
/// 
/// </summary>
public ColorI dragRectColor
       {
       get
          {
          if (_dragRectColor!=null)
              _dragRectColor.DetachAllEvents();
           _dragRectColor = dnTorque.self.GetVar(_mSimObjectId + ".dragRectColor").AsColorI();
          _dragRectColor.OnChangeNotification +=_dragRectColor_OnChangeNotification;
          return _dragRectColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dragRectColor", value.AsString());
          }
       }
void _dragRectColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".dragRectColor", e.NewValue);
       }
/// <summary>
/// 
/// </summary>
public bool dropAtBounds
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".dropAtBounds").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dropAtBounds", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public float dropAtScreenCenterMax
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".dropAtScreenCenterMax").AsFloat();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dropAtScreenCenterMax", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public float dropAtScreenCenterScalar
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".dropAtScreenCenterScalar").AsFloat();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dropAtScreenCenterScalar", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public float dropBelowCameraOffset
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".dropBelowCameraOffset").AsFloat();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dropBelowCameraOffset", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public WorldEditor__DropType dropType
       {
       get
          {          return (WorldEditor__DropType)Enum.Parse(typeof(WorldEditor__DropType), dnTorque.self.GetVar(_mSimObjectId + ".dropType"));
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dropType", value.ToString());
          }
       }
private ColorI _faceSelectColor = null;
/// <summary>
/// 
/// </summary>
public ColorI faceSelectColor
       {
       get
          {
          if (_faceSelectColor!=null)
              _faceSelectColor.DetachAllEvents();
           _faceSelectColor = dnTorque.self.GetVar(_mSimObjectId + ".faceSelectColor").AsColorI();
          _faceSelectColor.OnChangeNotification +=_faceSelectColor_OnChangeNotification;
          return _faceSelectColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".faceSelectColor", value.AsString());
          }
       }
void _faceSelectColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".faceSelectColor", e.NewValue);
       }
/// <summary>
/// Whether object icons should fade out with distance to camera pos. 
/// </summary>
public bool fadeIcons
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".fadeIcons").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".fadeIcons", value.AsString());
          }
       }
/// <summary>
/// Distance from camera pos at which to start fading out icons. 
/// </summary>
public float fadeIconsDist
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".fadeIconsDist").AsFloat();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".fadeIconsDist", value.AsString());
          }
       }
/// <summary>
/// If true, transform operations will snap to the grid. 
/// </summary>
public bool gridSnap
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".gridSnap").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".gridSnap", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool isDirty
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".isDirty").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".isDirty", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public String lockedHandle
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".lockedHandle").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".lockedHandle", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool objectMeshCollision
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".objectMeshCollision").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objectMeshCollision", value.AsString());
          }
       }
/// <summary>
///  
/// </summary>
public bool objectsUseBoxCenter
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".objectsUseBoxCenter").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objectsUseBoxCenter", value.AsString());
          }
       }
private ColorI _objectTextColor = null;
/// <summary>
/// 
/// </summary>
public ColorI objectTextColor
       {
       get
          {
          if (_objectTextColor!=null)
              _objectTextColor.DetachAllEvents();
           _objectTextColor = dnTorque.self.GetVar(_mSimObjectId + ".objectTextColor").AsColorI();
          _objectTextColor.OnChangeNotification +=_objectTextColor_OnChangeNotification;
          return _objectTextColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objectTextColor", value.AsString());
          }
       }
void _objectTextColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".objectTextColor", e.NewValue);
       }
private ColorI _objMouseOverColor = null;
/// <summary>
/// 
/// </summary>
public ColorI objMouseOverColor
       {
       get
          {
          if (_objMouseOverColor!=null)
              _objMouseOverColor.DetachAllEvents();
           _objMouseOverColor = dnTorque.self.GetVar(_mSimObjectId + ".objMouseOverColor").AsColorI();
          _objMouseOverColor.OnChangeNotification +=_objMouseOverColor_OnChangeNotification;
          return _objMouseOverColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objMouseOverColor", value.AsString());
          }
       }
void _objMouseOverColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".objMouseOverColor", e.NewValue);
       }
private ColorI _objMouseOverSelectColor = null;
/// <summary>
/// 
/// </summary>
public ColorI objMouseOverSelectColor
       {
       get
          {
          if (_objMouseOverSelectColor!=null)
              _objMouseOverSelectColor.DetachAllEvents();
           _objMouseOverSelectColor = dnTorque.self.GetVar(_mSimObjectId + ".objMouseOverSelectColor").AsColorI();
          _objMouseOverSelectColor.OnChangeNotification +=_objMouseOverSelectColor_OnChangeNotification;
          return _objMouseOverSelectColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objMouseOverSelectColor", value.AsString());
          }
       }
void _objMouseOverSelectColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".objMouseOverSelectColor", e.NewValue);
       }
private ColorI _objSelectColor = null;
/// <summary>
/// 
/// </summary>
public ColorI objSelectColor
       {
       get
          {
          if (_objSelectColor!=null)
              _objSelectColor.DetachAllEvents();
           _objSelectColor = dnTorque.self.GetVar(_mSimObjectId + ".objSelectColor").AsColorI();
          _objSelectColor.OnChangeNotification +=_objSelectColor_OnChangeNotification;
          return _objSelectColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objSelectColor", value.AsString());
          }
       }
void _objSelectColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".objSelectColor", e.NewValue);
       }
/// <summary>
/// 
/// </summary>
public String objTextFormat
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".objTextFormat").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".objTextFormat", value.AsString());
          }
       }
private ColorI _popupBackgroundColor = null;
/// <summary>
/// 
/// </summary>
public ColorI popupBackgroundColor
       {
       get
          {
          if (_popupBackgroundColor!=null)
              _popupBackgroundColor.DetachAllEvents();
           _popupBackgroundColor = dnTorque.self.GetVar(_mSimObjectId + ".popupBackgroundColor").AsColorI();
          _popupBackgroundColor.OnChangeNotification +=_popupBackgroundColor_OnChangeNotification;
          return _popupBackgroundColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".popupBackgroundColor", value.AsString());
          }
       }
void _popupBackgroundColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".popupBackgroundColor", e.NewValue);
       }
private ColorI _popupTextColor = null;
/// <summary>
/// 
/// </summary>
public ColorI popupTextColor
       {
       get
          {
          if (_popupTextColor!=null)
              _popupTextColor.DetachAllEvents();
           _popupTextColor = dnTorque.self.GetVar(_mSimObjectId + ".popupTextColor").AsColorI();
          _popupTextColor.OnChangeNotification +=_popupTextColor_OnChangeNotification;
          return _popupTextColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".popupTextColor", value.AsString());
          }
       }
void _popupTextColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".popupTextColor", e.NewValue);
       }
/// <summary>
/// 
/// </summary>
public bool renderObjHandle
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".renderObjHandle").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".renderObjHandle", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool renderObjText
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".renderObjText").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".renderObjText", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool renderPopupBackground
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".renderPopupBackground").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".renderPopupBackground", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool renderSelectionBox
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".renderSelectionBox").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".renderSelectionBox", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public String selectHandle
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".selectHandle").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".selectHandle", value.AsString());
          }
       }
private ColorI _selectionBoxColor = null;
/// <summary>
/// 
/// </summary>
public ColorI selectionBoxColor
       {
       get
          {
          if (_selectionBoxColor!=null)
              _selectionBoxColor.DetachAllEvents();
           _selectionBoxColor = dnTorque.self.GetVar(_mSimObjectId + ".selectionBoxColor").AsColorI();
          _selectionBoxColor.OnChangeNotification +=_selectionBoxColor_OnChangeNotification;
          return _selectionBoxColor;
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".selectionBoxColor", value.AsString());
          }
       }
void _selectionBoxColor_OnChangeNotification(object o, Notifier.ChangeNotificationEventArgs e)
       {
       dnTorque.self.SetVar(_mSimObjectId + ".selectionBoxColor", e.NewValue);
       }
/// <summary>
/// 
/// </summary>
public bool selectionLocked
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".selectionLocked").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".selectionLocked", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool showMousePopupInfo
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showMousePopupInfo").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showMousePopupInfo", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool stickToGround
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".stickToGround").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".stickToGround", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool toggleIgnoreList
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".toggleIgnoreList").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".toggleIgnoreList", value.AsString());
          }
       }
/// <summary>
/// ( WorldEditor, addUndoState, void, 2, 2, )
/// 
/// </summary>
public  void addUndoState(){
TorqueScriptTemplate.m_ts.fnWorldEditor_addUndoState(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, alignByAxis, void, 3, 3, (int axis)
///               Align all selected objects along the given axis.)
/// 
/// </summary>
public  void alignByAxis(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_alignByAxis(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, alignByBounds, void, 3, 3, (int boundsAxis)
///               Align all selected objects against the given bounds axis.)
/// 
/// </summary>
public  void alignByBounds(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_alignByBounds(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, canPasteSelection, bool, 2, 2, )
/// 
/// </summary>
public  bool canPasteSelection(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_canPasteSelection(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, clearIgnoreList, void, 2, 2, )
/// 
/// </summary>
public  void clearIgnoreList(){
TorqueScriptTemplate.m_ts.fnWorldEditor_clearIgnoreList(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, clearSelection, void, 2, 2, )
/// 
/// </summary>
public  void clearSelection(){
TorqueScriptTemplate.m_ts.fnWorldEditor_clearSelection(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, colladaExportSelection, void, 3, 3, 
///               ( String path ) - Export the combined geometry of all selected objects to the specified path in collada format. )
/// 
/// </summary>
public  void colladaExportSelection(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_colladaExportSelection(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, copySelection, void, 2, 2, )
/// 
/// </summary>
public  void copySelection(){
TorqueScriptTemplate.m_ts.fnWorldEditor_copySelection(_mSimObjectId);
}
/// <summary>
/// Create a ConvexShape from the given polyhedral object. )
/// 
/// </summary>
public  string createConvexShapeFrom(string polyObject){
return TorqueScriptTemplate.m_ts.fnWorldEditor_createConvexShapeFrom(_mSimObjectId, polyObject);
}
/// <summary>
/// Grab the geometry from @a geometryProvider, create a @a className object, and assign it the extracted geometry. )
/// 
/// </summary>
public  string createPolyhedralObject(string className, string geometryProvider){
return TorqueScriptTemplate.m_ts.fnWorldEditor_createPolyhedralObject(_mSimObjectId, className, geometryProvider);
}
/// <summary>
/// ( WorldEditor, cutSelection, void, 2, 2, )
/// 
/// </summary>
public  void cutSelection(){
TorqueScriptTemplate.m_ts.fnWorldEditor_cutSelection(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, dropSelection, void, 2, 3, ( bool skipUndo = false ))
/// 
/// </summary>
public  void dropSelection(string a2= ""){
TorqueScriptTemplate.m_ts.fnWorldEditor_dropSelection(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, explodeSelectedPrefab, void, 2, 2, () - Replace selected Prefab objects with a SimGroup containing all children objects defined in the .prefab. )
/// 
/// </summary>
public  void explodeSelectedPrefab(){
TorqueScriptTemplate.m_ts.fnWorldEditor_explodeSelectedPrefab(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getActiveSelection, S32, 2, 2, () - Return the currently active WorldEditorSelection object. )
/// 
/// </summary>
public  int getActiveSelection(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getActiveSelection(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSelectedObject, S32, 3, 3, (int index))
/// 
/// </summary>
public  int getSelectedObject(string a2){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSelectedObject(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, getSelectionCentroid, const char *, 2, 2, )
/// 
/// </summary>
public  string getSelectionCentroid(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSelectionCentroid(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSelectionExtent, const char *, 2, 2, )
/// 
/// </summary>
public  string getSelectionExtent(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSelectionExtent(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSelectionRadius, F32, 2, 2, )
/// 
/// </summary>
public  float getSelectionRadius(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSelectionRadius(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSelectionSize, S32, 2, 2, () - Return the number of objects currently selected in the editor.)
/// 
/// </summary>
public  int getSelectionSize(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSelectionSize(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSoftSnap, bool, 2, 2, getSoftSnap()
///               Is soft snapping always on?)
/// 
/// </summary>
public  bool getSoftSnap(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSoftSnap(_mSimObjectId);
}
/// <summary>
/// Get the soft snap alignment. )
/// 
/// </summary>
public  WorldEditor__AlignmentType getSoftSnapAlignment(){
return (WorldEditor__AlignmentType)( TorqueScriptTemplate.m_ts.fnWorldEditor_getSoftSnapAlignment(_mSimObjectId));
}
/// <summary>
/// ( WorldEditor, getSoftSnapBackfaceTolerance, F32, 2, 2, getSoftSnapBackfaceTolerance()
///               The fraction of the soft snap radius that backfaces may be included.)
/// 
/// </summary>
public  float getSoftSnapBackfaceTolerance(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSoftSnapBackfaceTolerance(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, getSoftSnapSize, F32, 2, 2, getSoftSnapSize()
///               Get the absolute size to trigger a soft snap.)
/// 
/// </summary>
public  float getSoftSnapSize(){
return TorqueScriptTemplate.m_ts.fnWorldEditor_getSoftSnapSize(_mSimObjectId);
}
/// <summary>
/// Get the terrain snap alignment.  )
/// 
/// </summary>
public  WorldEditor__AlignmentType getTerrainSnapAlignment(){
return (WorldEditor__AlignmentType)( TorqueScriptTemplate.m_ts.fnWorldEditor_getTerrainSnapAlignment(_mSimObjectId));
}
/// <summary>
/// ( WorldEditor, hideObject, void, 4, 4, (Object obj, bool hide))
/// 
/// </summary>
public  void hideObject(string a2, string a3){
TorqueScriptTemplate.m_ts.fnWorldEditor_hideObject(_mSimObjectId, a2, a3);
}
/// <summary>
/// ( WorldEditor, hideSelection, void, 3, 3, (bool hide))
/// 
/// </summary>
public  void hideSelection(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_hideSelection(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, ignoreObjClass, void, 3, 0, (string class_name, ...))
/// 
/// </summary>
public  void ignoreObjClass(string a2, string a3= "", string a4= "", string a5= "", string a6= "", string a7= "", string a8= "", string a9= "", string a10= "", string a11= "", string a12= "", string a13= "", string a14= "", string a15= "", string a16= "", string a17= "", string a18= "", string a19= ""){
TorqueScriptTemplate.m_ts.fnWorldEditor_ignoreObjClass(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}
/// <summary>
/// ( WorldEditor, invalidateSelectionCentroid, void, 2, 2, )
/// 
/// </summary>
public  void invalidateSelectionCentroid(){
TorqueScriptTemplate.m_ts.fnWorldEditor_invalidateSelectionCentroid(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, lockSelection, void, 3, 3, (bool lock))
/// 
/// </summary>
public  void lockSelection(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_lockSelection(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, makeSelectionPrefab, void, 3, 3, ( string filename ) - Save selected objects to a .prefab file and replace them in the level with a Prefab object. )
/// 
/// </summary>
public  void makeSelectionPrefab(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_makeSelectionPrefab(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, mountRelative, void, 4, 4, ( Object A, Object B ) )
/// 
/// </summary>
public  void mountRelative(string a2, string a3){
TorqueScriptTemplate.m_ts.fnWorldEditor_mountRelative(_mSimObjectId, a2, a3);
}
/// <summary>
/// ( WorldEditor, pasteSelection, void, 2, 2, )
/// 
/// </summary>
public  void pasteSelection(){
TorqueScriptTemplate.m_ts.fnWorldEditor_pasteSelection(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, redirectConsole, void, 3, 3, ( int objID ))
/// 
/// </summary>
public  void redirectConsole(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_redirectConsole(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, resetSelectedRotation, void, 2, 2, )
/// 
/// </summary>
public  void resetSelectedRotation(){
TorqueScriptTemplate.m_ts.fnWorldEditor_resetSelectedRotation(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, resetSelectedScale, void, 2, 2, )
/// 
/// </summary>
public  void resetSelectedScale(){
TorqueScriptTemplate.m_ts.fnWorldEditor_resetSelectedScale(_mSimObjectId);
}
/// <summary>
/// ( WorldEditor, selectObject, void, 3, 3, (SimObject obj))
/// 
/// </summary>
public  void selectObject(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_selectObject(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, setActiveSelection, void, 3, 3, ( id set ) - Set the currently active WorldEditorSelection object. )
/// 
/// </summary>
public  void setActiveSelection(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_setActiveSelection(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, setSoftSnap, void, 3, 3, setSoftSnap(bool)
///               Allow soft snapping all of the time.)
/// 
/// </summary>
public  void setSoftSnap(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_setSoftSnap(_mSimObjectId, a2);
}
/// <summary>
/// Set the soft snap alignment. )
/// 
/// </summary>
public  void setSoftSnapAlignment(WorldEditor__AlignmentType type){
TorqueScriptTemplate.m_ts.fnWorldEditor_setSoftSnapAlignment(_mSimObjectId, (int)type );
}
/// <summary>
/// ( WorldEditor, setSoftSnapBackfaceTolerance, void, 3, 3, setSoftSnapBackfaceTolerance(F32 with range of 0..1)
///               The fraction of the soft snap radius that backfaces may be included.)
/// 
/// </summary>
public  void setSoftSnapBackfaceTolerance(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_setSoftSnapBackfaceTolerance(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, setSoftSnapSize, void, 3, 3, setSoftSnapSize(F32)
///               Set the absolute size to trigger a soft snap.)
/// 
/// </summary>
public  void setSoftSnapSize(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_setSoftSnapSize(_mSimObjectId, a2);
}
/// <summary>
/// Set the terrain snap alignment. )
/// 
/// </summary>
public  void setTerrainSnapAlignment(WorldEditor__AlignmentType alignment){
TorqueScriptTemplate.m_ts.fnWorldEditor_setTerrainSnapAlignment(_mSimObjectId, (int)alignment );
}
/// <summary>
/// ( WorldEditor, softSnapDebugRender, void, 3, 3, softSnapDebugRender(bool)
///               Toggle soft snapping debug rendering.)
/// 
/// </summary>
public  void softSnapDebugRender(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_softSnapDebugRender(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, softSnapRender, void, 3, 3, softSnapRender(bool)
///               Render the soft snapping bounds.)
/// 
/// </summary>
public  void softSnapRender(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_softSnapRender(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, softSnapRenderTriangle, void, 3, 3, softSnapRenderTriangle(bool)
///               Render the soft snapped triangle.)
/// 
/// </summary>
public  void softSnapRenderTriangle(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_softSnapRenderTriangle(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, softSnapSizeByBounds, void, 3, 3, softSnapSizeByBounds(bool)
///               Use selection bounds size as soft snap bounds.)
/// 
/// </summary>
public  void softSnapSizeByBounds(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_softSnapSizeByBounds(_mSimObjectId, a2);
}
/// <summary>
/// ( WorldEditor, transformSelection, void, 13, 13, transformSelection(...)
///               Transform selection by given parameters.)
/// 
/// </summary>
public  void transformSelection(string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12){
TorqueScriptTemplate.m_ts.fnWorldEditor_transformSelection(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}
/// <summary>
/// ( WorldEditor, unselectObject, void, 3, 3, (SimObject obj))
/// 
/// </summary>
public  void unselectObject(string a2){
TorqueScriptTemplate.m_ts.fnWorldEditor_unselectObject(_mSimObjectId, a2);
}
}}
