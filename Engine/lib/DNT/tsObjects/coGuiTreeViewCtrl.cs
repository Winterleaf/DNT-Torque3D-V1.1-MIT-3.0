
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoGuiTreeViewCtrl : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coGuiTreeViewCtrl(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoGuiTreeViewCtrl))]
    public class coGuiTreeViewCtrl: coGuiArrayCtrl
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiTreeViewCtrl(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiTreeViewCtrl(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coGuiTreeViewCtrl(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coGuiTreeViewCtrl ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coGuiTreeViewCtrl ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coGuiTreeViewCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiTreeViewCtrl(string ts)
            {
            return new coGuiTreeViewCtrl(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coGuiTreeViewCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiTreeViewCtrl(int ts)
            {
            return new coGuiTreeViewCtrl(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coGuiTreeViewCtrl ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coGuiTreeViewCtrl(uint ts)
            {
            return new coGuiTreeViewCtrl(ts);
            }
/// <summary>
/// If true clicking on a selected item ( that is an object and not the root ) will allow you to rename it. 
/// </summary>
public bool canRenameObjects
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".canRenameObjects").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".canRenameObjects", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool clearAllOnSingleSelection
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".clearAllOnSingleSelection").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".clearAllOnSingleSelection", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool compareToObjectID
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".compareToObjectID").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".compareToObjectID", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool deleteObjectAllowed
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".deleteObjectAllowed").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".deleteObjectAllowed", value.AsString());
          }
       }
/// <summary>
/// If true, the entire tree item hierarchy is deleted when the control goes to sleep. 
/// </summary>
public bool destroyTreeOnSleep
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".destroyTreeOnSleep").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".destroyTreeOnSleep", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool dragToItemAllowed
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".dragToItemAllowed").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".dragToItemAllowed", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool fullRowSelect
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".fullRowSelect").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".fullRowSelect", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public int itemHeight
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".itemHeight").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".itemHeight", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool mouseDragging
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".mouseDragging").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".mouseDragging", value.AsString());
          }
       }
/// <summary>
/// If true, multiple items can be selected concurrently. 
/// </summary>
public bool multipleSelections
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".multipleSelections").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".multipleSelections", value.AsString());
          }
       }
/// <summary>
/// If true then object renaming operates on the internalName rather than the object name. 
/// </summary>
public bool renameInternal
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".renameInternal").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".renameInternal", value.AsString());
          }
       }
/// <summary>
/// If true, class names will be used as object names for unnamed objects. 
/// </summary>
public bool showClassNameForUnnamedObjects
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showClassNameForUnnamedObjects").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showClassNameForUnnamedObjects", value.AsString());
          }
       }
/// <summary>
/// If true, item text labels for objects will include class names. 
/// </summary>
public bool showClassNames
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showClassNames").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showClassNames", value.AsString());
          }
       }
/// <summary>
/// If true, item text labels for obje ts will include internal names. 
/// </summary>
public bool showInternalNames
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showInternalNames").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showInternalNames", value.AsString());
          }
       }
/// <summary>
/// If true, item text labels for objects will include object IDs. 
/// </summary>
public bool showObjectIds
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showObjectIds").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showObjectIds", value.AsString());
          }
       }
/// <summary>
/// If true, item text labels for objects will include object names. 
/// </summary>
public bool showObjectNames
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showObjectNames").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showObjectNames", value.AsString());
          }
       }
/// <summary>
/// If true, the root item is shown in the tree. 
/// </summary>
public bool showRoot
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".showRoot").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".showRoot", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public int tabSize
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".tabSize").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".tabSize", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public int textOffset
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".textOffset").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".textOffset", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool tooltipOnWidthOnly
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".tooltipOnWidthOnly").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".tooltipOnWidthOnly", value.AsString());
          }
       }
/// <summary>
/// 
/// </summary>
public bool useInspectorTooltips
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".useInspectorTooltips").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".useInspectorTooltips", value.AsString());
          }
       }
/// <summary>
/// (GuiTreeViewCtrl, addChildSelectionByValue, void, 4, 4, addChildSelectionByValue(TreeItemId parent, value))
/// 
/// </summary>
public  void addChildSelectionByValue(string a2, string a3){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_addChildSelectionByValue(_mSimObjectId, a2, a3);
}
/// <summary>
/// Add an item/object to the current selection.
///    @param id ID of item/object to add to the selection.
///    @param isLastSelection Whether there are more pending items/objects to be added to the selection.  If false, 
///       the control will defer refreshing the tree and wait until addSelection() is called with this parameter set 
///       to true. )
/// 
/// </summary>
public  void addSelection(int id, bool isLastSelection){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_addSelection(_mSimObjectId, id, isLastSelection);
}
/// <summary>
/// (GuiTreeViewCtrl, buildIconTable, bool, 3,3, (builds an icon table))
/// 
/// </summary>
public  bool buildIconTable(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_buildIconTable(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, buildVisibleTree, void, 2, 3, Build the visible tree)
/// 
/// </summary>
public  void buildVisibleTree(string a2= ""){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_buildVisibleTree(_mSimObjectId, a2);
}
/// <summary>
/// ( GuiTreeViewCtrl, cancelRename, void, 2, 2, For internal use. )
/// 
/// </summary>
public  void cancelRename(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_cancelRename(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, clear, void, 2, 2, () - empty tree)
/// 
/// </summary>
public  new  void clear(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_clear(_mSimObjectId);
}
/// <summary>
/// Clear the current item filtering pattern.
///    @see setFilterText
///    @see getFilterText )
/// 
/// </summary>
public  void clearFilterText(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_clearFilterText(_mSimObjectId);
}
/// <summary>
/// Unselect all currently selected items. )
/// 
/// </summary>
public  void clearSelection(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_clearSelection(_mSimObjectId);
}
/// <summary>
/// Delete all items/objects in the current selection. )
/// 
/// </summary>
public  void deleteSelection(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_deleteSelection(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, editItem, bool, 5, 5, (TreeItemId item, string newText, string newValue))
/// 
/// </summary>
public  bool editItem(string a2, string a3, string a4){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_editItem(_mSimObjectId, a2, a3, a4);
}
/// <summary>
/// (GuiTreeViewCtrl, expandItem, bool, 3, 4, (TreeItemId item, bool expand=true))
/// 
/// </summary>
public  bool expandItem(string a2, string a3= ""){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_expandItem(_mSimObjectId, a2, a3);
}
/// <summary>
/// Get the child item of the given parent item whose text matches @a childName.
///    @param parentId Item ID of the parent in which to look for the child.
///    @param childName Text of the child item to find.
///    @return ID of the child item or -1 if no child in @a parentId has the given text @a childName.
///    @note This method does not recurse, i.e. it only looks for direct children. )
/// 
/// </summary>
public  int findChildItemByName(int parentId, string childName){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_findChildItemByName(_mSimObjectId, parentId, childName);
}
/// <summary>
/// Get the ID of the item whose text matches the given @a text.
///    @param text Item text to match.
///    @return ID of the item or -1 if no item matches the given text. )
/// 
/// </summary>
public  int findItemByName(string text){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_findItemByName(_mSimObjectId, text);
}
/// <summary>
/// (GuiTreeViewCtrl, findItemByObjectId, S32, 3, 3, (find item by object id and returns the mId))
/// 
/// </summary>
public  int findItemByObjectId(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_findItemByObjectId(_mSimObjectId, a2);
}
/// <summary>
/// Get the ID of the item whose value matches @a value.
///    @param value Value text to match.
///    @return ID of the item or -1 if no item has the given value. )
/// 
/// </summary>
public  int findItemByValue(string value){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_findItemByValue(_mSimObjectId, value);
}
/// <summary>
/// (GuiTreeViewCtrl, getChild, S32, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  int getChild(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getChild(_mSimObjectId, a2);
}
/// <summary>
/// Get the current filter expression.  Only tree items whose text matches this expression 
///    are displayed.  By default, the expression is empty and all items are shown.
///    @return The current filter pattern or an empty string if no filter pattern is currently active.
///    @see setFilterText
///    @see clearFilterText )
/// 
/// </summary>
public  string getFilterText(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getFilterText(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getFirstRootItem, S32, 2, 2, Get id for root item.)
/// 
/// </summary>
public  int getFirstRootItem(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getFirstRootItem(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getItemCount, S32, 2, 2, )
/// 
/// </summary>
public  int getItemCount(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getItemCount(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getItemText, const char *, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  string getItemText(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getItemText(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getItemValue, const char *, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  string getItemValue(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getItemValue(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getNextSibling, S32, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  int getNextSibling(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getNextSibling(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getParent, S32, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  int getParent(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getParent(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getPrevSibling, S32, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  int getPrevSibling(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getPrevSibling(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getSelectedItem, S32, 2, 3, ( int index=0 ) - Return the selected item at the given index.)
/// 
/// </summary>
public  int getSelectedItem(string a2= ""){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getSelectedItem(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getSelectedItemList,const char*, 2,2,returns a space seperated list of mulitple item ids)
/// 
/// </summary>
public  string getSelectedItemList(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getSelectedItemList(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getSelectedItemsCount, S32, 2, 2, )
/// 
/// </summary>
public  int getSelectedItemsCount(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getSelectedItemsCount(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getSelectedObject, S32, 2, 3, ( int index=0 ) - Return the currently selected SimObject at the given index in inspector mode or -1)
/// 
/// </summary>
public  int getSelectedObject(string a2= ""){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getSelectedObject(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, getSelectedObjectList, const char*, 2, 2, 
///               Returns a space sperated list of all selected object ids.)
/// 
/// </summary>
public  string getSelectedObjectList(){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getSelectedObjectList(_mSimObjectId);
}
/// <summary>
/// (GuiTreeViewCtrl, getTextToRoot, const char*,4,4,(TreeItemId item,Delimiter=none) gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally)
/// 
/// </summary>
public  string getTextToRoot(string a2, string a3){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_getTextToRoot(_mSimObjectId, a2, a3);
}
/// <summary>
/// Call SimObject::setHidden( @a state ) on all objects in the current selection.
///    @param state Visibility state to set objects in selection to. )
/// 
/// </summary>
public  void hideSelection(bool state){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_hideSelection(_mSimObjectId, state);
}
/// <summary>
/// , , 0, 0 ),
///    Add a new item to the tree.
///    @param parentId Item ID of parent to which to add the item as a child.  0 is root item.
///    @param text Text to display on the item in the tree.
///    @param value Behind-the-scenes value of the item.
///    @param icon
///    @param normalImage
///    @param expandedImage
///    @return The ID of the newly added item. )
/// 
/// </summary>
public  int insertItem(int parentId, string text, string value, string icon, int normalImage, int expandedImage){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_insertItem(_mSimObjectId, parentId, text, value, icon, normalImage, expandedImage);
}
/// <summary>
/// Check whether the given item is currently selected in the tree.
///    @param id Item/object ID.
///    @return True if the given item/object is currently selected in the tree. )
/// 
/// </summary>
public  bool isItemSelected(int id){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_isItemSelected(_mSimObjectId, id);
}
/// <summary>
/// ( GuiTreeViewCtrl, isParentItem, bool, 3, 3, ( int id ) - Returns true if the given item contains child items. )
/// 
/// </summary>
public  bool isParentItem(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_isParentItem(_mSimObjectId, a2);
}
/// <summary>
/// Set whether the current selection can be changed by the user or not.
///    @param lock If true, the current selection is frozen and cannot be changed.  If false, 
///       the selection may be modified. )
/// 
/// </summary>
public  void lockSelection(bool xlock){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_lockSelection(_mSimObjectId, xlock);
}
/// <summary>
/// (GuiTreeViewCtrl, markItem, bool, 3, 4, (TreeItemId item, bool mark=true))
/// 
/// </summary>
public  bool markItem(string a2, string a3= ""){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_markItem(_mSimObjectId, a2, a3);
}
/// <summary>
/// (GuiTreeViewCtrl, moveItemDown, void, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  void moveItemDown(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_moveItemDown(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, moveItemUp, void, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  void moveItemUp(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_moveItemUp(_mSimObjectId, a2);
}
/// <summary>
/// ( GuiTreeViewCtrl, onRenameValidate, void, 2, 2, For internal use. )
/// 
/// </summary>
public  void onRenameValidate(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_onRenameValidate(_mSimObjectId);
}
/// <summary>
/// ( GuiTreeViewCtrl, open, void, 3, 4, (SimSet obj, bool okToEdit=true) Set the root of the tree view to the specified object, or to the root set.)
/// 
/// </summary>
public  void open(string a2, string a3= ""){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_open(_mSimObjectId, a2, a3);
}
/// <summary>
/// (GuiTreeViewCtrl, removeAllChildren, void, 3, 3, removeAllChildren(TreeItemId parent))
/// 
/// </summary>
public  void removeAllChildren(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_removeAllChildren(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, removeChildSelectionByValue, void, 4, 4, removeChildSelectionByValue(TreeItemId parent, value))
/// 
/// </summary>
public  void removeChildSelectionByValue(string a2, string a3){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_removeChildSelectionByValue(_mSimObjectId, a2, a3);
}
/// <summary>
/// (GuiTreeViewCtrl, removeItem, bool, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  bool removeItem(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_removeItem(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, removeSelection, void, 3, 3, (deselects an item))
/// 
/// </summary>
public  void removeSelection(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_removeSelection(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, scrollVisible, void, 3, 3, (TreeItemId item))
/// 
/// </summary>
public  void scrollVisible(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_scrollVisible(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, scrollVisibleByObjectId, S32, 3, 3, (show item by object id. returns true if sucessful.))
/// 
/// </summary>
public  int scrollVisibleByObjectId(string a2){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_scrollVisibleByObjectId(_mSimObjectId, a2);
}
/// <summary>
/// (GuiTreeViewCtrl, selectItem, bool, 3, 4, (TreeItemId item, bool select=true))
/// 
/// </summary>
public  bool selectItem(string a2, string a3= ""){
return TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_selectItem(_mSimObjectId, a2, a3);
}
/// <summary>
/// ( GuiTreeViewCtrl, setDebug, void, 2, 3, ( bool value=true ) - Enable/disable debug output. )
/// 
/// </summary>
public  void setDebug(string a2= ""){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_setDebug(_mSimObjectId, a2);
}
/// <summary>
/// Set the pattern by which to filter items in the tree.  Only items in the tree whose text 
///    matches this pattern are displayed.
///    @param pattern New pattern based on which visible items in the tree should be filtered.  If empty, all items become visible.
///    @see getFilterText
///    @see clearFilterText )
/// 
/// </summary>
public  void setFilterText(string pattern){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_setFilterText(_mSimObjectId, pattern);
}
/// <summary>
/// ( GuiTreeViewCtrl, setItemImages, void, 5, 5, ( int id, int normalImage, int expandedImage ) - Sets the normal and expanded images to show for the given item. )
/// 
/// </summary>
public  void setItemImages(string a2, string a3, string a4){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_setItemImages(_mSimObjectId, a2, a3, a4);
}
/// <summary>
/// ( GuiTreeViewCtrl, setItemTooltip, void, 4, 4, ( int id, string text ) - Set the tooltip to show for the given item. )
/// 
/// </summary>
public  void setItemTooltip(string a2, string a3){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_setItemTooltip(_mSimObjectId, a2, a3);
}
/// <summary>
/// ( GuiTreeViewCtrl, showItemRenameCtrl, void, 3, 3, ( TreeItemId id ) - Show the rename text field for the given item (only one at a time). )
/// 
/// </summary>
public  void showItemRenameCtrl(string a2){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_showItemRenameCtrl(_mSimObjectId, a2);
}
/// <summary>
/// ( GuiTreeViewCtrl, sort, void, 2, 6, ( int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true ) - Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy. )
/// 
/// </summary>
public  void sort(string a2= "", string a3= "", string a4= "", string a5= ""){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_sort(_mSimObjectId, a2, a3, a4, a5);
}
/// <summary>
/// Toggle the hidden state of all objects in the current selection. )
/// 
/// </summary>
public  void toggleHideSelection(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_toggleHideSelection(_mSimObjectId);
}
/// <summary>
/// Toggle the locked state of all objects in the current selection. )
/// 
/// </summary>
public  void toggleLockSelection(){
TorqueScriptTemplate.m_ts.fnGuiTreeViewCtrl_toggleLockSelection(_mSimObjectId);
}
}}
