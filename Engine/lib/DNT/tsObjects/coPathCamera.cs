
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoPathCamera : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coPathCamera(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoPathCamera))]
    public class coPathCamera: coShapeBase
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coPathCamera(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coPathCamera(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coPathCamera(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coPathCamera ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coPathCamera ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coPathCamera ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coPathCamera(string ts)
            {
            return new coPathCamera(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coPathCamera ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coPathCamera(int ts)
            {
            return new coPathCamera(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coPathCamera ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coPathCamera(uint ts)
            {
            return new coPathCamera(ts);
            }
/// <summary>
/// Removes the knot at the front of the camera's path.
/// 													@tsexample
/// 														// Remove the first knot in the camera's path.
/// 														%pathCamera.popFront();
/// 													@endtsexample)
/// 
/// </summary>
public  void popFront(){
TorqueScriptTemplate.m_ts.fnPathCamera_popFront(_mSimObjectId);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the back of a path camera's path.
/// 													@param transform Transform for the new knot.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\"
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the path camera to add a new knot to the back of its path
/// 														%pathCamera.pushBack(%transform,%speed,%type,%path);
/// 													@endtsexample)
/// 
/// </summary>
public  void pushBack(TransformF transform, float speed, string type, string path){
TorqueScriptTemplate.m_ts.fnPathCamera_pushBack(_mSimObjectId, transform.AsString(), speed, type, path);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the front of a path camera's path.
/// 													@param transform Transform for the new knot. In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\";
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the path camera to add a new knot to the front of its path
/// 														%pathCamera.pushFront(%transform, %speed, %type, %path);
/// 													@endtsexample)
/// 
/// </summary>
public  void pushFront(TransformF transform, float speed, string type, string path){
TorqueScriptTemplate.m_ts.fnPathCamera_pushFront(_mSimObjectId, transform.AsString(), speed, type, path);
}
/// <summary>
/// @brief Clear the camera's path and set the camera's current transform as the start of the new path.
///                                        What specifically occurs is a new knot is created from the camera's current transform.  Then the current path 
///                                        is cleared and the new knot is pushed onto the path.  Any previous target is cleared and the camera's movement 
///                                        state is set to Forward.  The camera is now ready for a new path to be defined.
/// 													@param speed Speed for the camera to move along its path after being reset.
/// 													@tsexample
/// 														//Determine the new movement speed of this camera. If not set, the speed will default to 1.0.
/// 														%speed = \"0.50\";
/// 														// Inform the path camera to start a new path at
///                                           // the camera's current position, and set the new 
///                                           // path's speed value.
/// 														%pathCamera.reset(%speed);
///                                        @endtsexample)
/// 
/// </summary>
public  void reset(float speed){
TorqueScriptTemplate.m_ts.fnPathCamera_reset(_mSimObjectId, speed);
}
/// <summary>
/// Set the current position of the camera along the path.
/// 													@param position Position along the path, from 0.0 (path start) - 1.0 (path end), to place the camera.
/// 													@tsexample
///                                           // Set the camera on a position along its path from 0.0 - 1.0.
/// 														%position = \"0.35\";
/// 														// Force the pathCamera to its new position along the path.
/// 														%pathCamera.setPosition(%position);
/// 													@endtsexample)
/// 
/// </summary>
public  void setPosition(float position){
TorqueScriptTemplate.m_ts.fnPathCamera_setPosition(_mSimObjectId, position);
}
/// <summary>
/// forward), Set the movement state for this path camera.
/// 													@param newState New movement state type for this camera. Forward, Backward or Stop.
/// 													@tsexample
/// 														// Set the state type (forward, backward, stop).
///                                           // In this example, the camera will travel from the first node
///                                           // to the last node (or target if given with setTarget())
/// 														%state = \"forward\";
/// 														// Inform the pathCamera to change its movement state to the defined value.
/// 														%pathCamera.setState(%state);
/// 													@endtsexample)
/// 
/// </summary>
public  void setState(string newState){
TorqueScriptTemplate.m_ts.fnPathCamera_setState(_mSimObjectId, newState);
}
/// <summary>
/// @brief Set the movement target for this camera along its path.
///                                        The camera will attempt to move along the path to the given target in the direction provided 
///                                        by setState() (the default is forwards).  Once the camera moves past this target it will come 
///                                        to a stop, and the target state will be cleared.
/// 													@param position Target position, between 0.0 (path start) and 1.0 (path end), for the camera to move to along its path.
/// 													@tsexample
///                                           // Set the position target, between 0.0 (path start) and 1.0 (path end), for this camera to move to.
/// 														%position = \"0.50\";
/// 														// Inform the pathCamera of the new target position it will move to.
/// 														%pathCamera.setTarget(%position);
/// 													@endtsexample)
/// 
/// </summary>
public  void setTarget(float position){
TorqueScriptTemplate.m_ts.fnPathCamera_setTarget(_mSimObjectId, position);
}
}}
