
// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.

#region
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using System.ComponentModel;
using System.Threading;
#endregion

namespace WinterLeaf.tsObjects
    {
    /// <summary>
    /// 
    /// </summary>
    internal class tsObjectConvertercoSimObject : TypeConverter
        {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="sourceType"></param>
        /// <returns></returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
            return (typeof(string) == sourceType);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="culture"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
            {
            if (value is string)
                {
                return new coSimObject(value as string);
                }

            return null;
            }
        }

      
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(tsObjectConvertercoSimObject))]
    public class coSimObject: Classes.tsObject
{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSimObject(string simobjectid) : base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSimObject(uint simobjectid): base(simobjectid){ }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="simobjectid"></param>
internal coSimObject(int simobjectid): base(simobjectid){ }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator ==(coSimObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return object.ReferenceEquals(simobjectid, null);
            return ts.Equals(simobjectid);


            }
  /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
            {
            throw new NotImplementedException();
            }
  /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
            {
            
            return (this._mSimObjectId ==(string)myReflections.ChangeType( obj,typeof(string)));
            }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="simobjectid"></param>
        /// <returns></returns>
        public static bool operator !=(coSimObject ts, string simobjectid)
            {
            if (object.ReferenceEquals(ts, null))
                return !object.ReferenceEquals(simobjectid, null);
            return !ts.Equals(simobjectid);

            }


            /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator string( coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return "0";
            return ts._mSimObjectId;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(string ts)
            {
            return new coSimObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator int( coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            int i;
            return int.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(int ts)
            {
            return new coSimObject(ts);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator uint( coSimObject ts)
            {
            if (object.ReferenceEquals(ts, null))
                 return 0;
            uint i;
            return uint.TryParse(ts._mSimObjectId, out i) ? i : 0;
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public static implicit operator coSimObject(uint ts)
            {
            return new coSimObject(ts);
            }
/// <summary>
/// Whether the object can be saved out. If false, the object is purely transient in nature. 
/// </summary>
public bool canSave
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".canSave").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".canSave", value.AsString());
          }
       }
/// <summary>
/// True if dynamic fields (added at runtime) should be saved. Defaults to true. 
/// </summary>
public bool canSaveDynamicFields
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".canSaveDynamicFields").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".canSaveDynamicFields", value.AsString());
          }
       }
/// <summary>
/// Script class of object. 
/// </summary>
public String classx
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".class").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".class", value.AsString());
          }
       }
/// <summary>
/// Script class of object., AbstractClassRep::FIELD_HideInInspectors 
/// </summary>
public String className
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".className").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".className", value.AsString());
          }
       }
/// <summary>
/// Whether the object is visible. 
/// </summary>
public bool hidden
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".hidden").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".hidden", value.AsString());
          }
       }
/// <summary>
/// Optional name that may be used to lookup this object within a SimSet.
/// </summary>
public String internalName
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".internalName").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".internalName", value.AsString());
          }
       }
/// <summary>
/// Whether the object can be edited. 
/// </summary>
public bool lockedx
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".locked").AsBool();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".locked", value.AsString());
          }
       }
/// <summary>
/// Optional global name of this object. 
/// </summary>
public String name
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".name").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".name", value.AsString());
          }
       }
/// <summary>
/// Group hierarchy parent of the object. 
/// </summary>
public coSimObject parentGroup
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".parentGroup");
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".parentGroup", value.ToString());
          }
       }
/// <summary>
/// The universally unique identifier for the object. 
/// </summary>
public int persistentId
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".persistentId").AsInt();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".persistentId", value.AsString());
          }
       }
/// <summary>
/// Script super-class of object. 
/// </summary>
public String superClass
       {
       get
          {
          return dnTorque.self.GetVar(_mSimObjectId + ".superClass").AsString();
          }
       set
          {
          dnTorque.self.SetVar(_mSimObjectId + ".superClass", value.AsString());
          }
       }
/// <summary>
/// Copy fields from another object onto this one.  The objects must 
///    be of same type. Everything from the object will overwrite what's 
///    in this object; extra fields in this object will remain. This 
///    includes dynamic fields.
///    @param fromObject The object from which to copy fields. )
/// 
/// </summary>
public  void assignFieldsFrom(string fromObject){
TorqueScriptTemplate.m_ts.fn_SimObject_assignFieldsFrom(_mSimObjectId, fromObject);
}
/// <summary>
/// Delete and remove the object. )
/// 
/// </summary>
public  void delete(){
TorqueScriptTemplate.m_ts.fn_SimObject_delete(_mSimObjectId);
}
/// <summary>
/// Dump the native C++ class hierarchy of this object's C++ class to the console. )
/// 
/// </summary>
public  void dumpClassHierarchy(){
TorqueScriptTemplate.m_ts.fn_SimObject_dumpClassHierarchy(_mSimObjectId);
}
/// <summary>
/// List the methods defined on this object.
///    Each description is a newline-separated vector with the following elements:
///    - Minimum number of arguments.
///    - Maximum number of arguments.
///    - Prototype string.
///    - Full script file path (if script method).
///    - Line number of method definition in script (if script method).
///    - Documentation string (not including prototype).  This takes up the remainder of the vector.
///    @return An ArrayObject populated with (name,description) pairs of all methods defined on the object. )
/// 
/// </summary>
public  string dumpMethods(){
return TorqueScriptTemplate.m_ts.fn_SimObject_dumpMethods(_mSimObjectId);
}
/// <summary>
/// Get whether the object will be included in saves.
///    @return True if the object will be saved; false otherwise. )
/// 
/// </summary>
public  bool getCanSave(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getCanSave(_mSimObjectId);
}
/// <summary>
/// Get the name of the C++ class which the object is an instance of.
///    @return The name of the C++ class of the object. )
/// 
/// </summary>
public  string getClassName(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getClassName(_mSimObjectId);
}
/// <summary>
/// Get the name of the class namespace assigned to this object.
///    @return The name of the 'class' namespace. )
/// 
/// </summary>
public  string getClassNamespace(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getClassNamespace(_mSimObjectId);
}
/// <summary>
/// Get the line number at which the object is defined in its file.
///    @return The line number of the object's definition in script.
///    @see getFilename())
/// 
/// </summary>
public  int getDeclarationLine(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getDeclarationLine(_mSimObjectId);
}
/// <summary>
/// Get a value of a dynamic field by index.
///    @param index The index of the dynamic field.
///    @return The value of the dynamic field at the given index or \"\". )
/// 
/// </summary>
public  string getDynamicField(int index){
return TorqueScriptTemplate.m_ts.fn_SimObject_getDynamicField(_mSimObjectId, index);
}
/// <summary>
/// Get the number of dynamic fields defined on the object.
///    @return The number of dynamic fields defined on the object. )
/// 
/// </summary>
public  int getDynamicFieldCount(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getDynamicFieldCount(_mSimObjectId);
}
/// <summary>
/// Retrieve the value of a static field by index.
///    @param index The index of the static field.
///    @return The value of the static field with the given index or \"\". )
/// 
/// </summary>
public  string getField(int index){
return TorqueScriptTemplate.m_ts.fn_SimObject_getField(_mSimObjectId, index);
}
/// <summary>
/// Get the number of static fields on the object.
///    @return The number of static fields defined on the object. )
/// 
/// </summary>
public  int getFieldCount(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldCount(_mSimObjectId);
}
/// <summary>
/// Get the console type code of the given field.
///    @return The numeric type code for the underlying console type of the given field. )
/// 
/// </summary>
public  string getFieldType(string fieldName){
return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldType(_mSimObjectId, fieldName);
}
/// <summary>
/// Return the value of the given field on this object.
///    @param fieldName The name of the field.  If it includes a field index, the index is parsed out.
///    @param index Optional parameter to specify the index of an array field separately.
///    @return The value of the given field or \"\" if undefined. )
/// 
/// </summary>
public  string getFieldValue(string fieldName, int index){
return TorqueScriptTemplate.m_ts.fn_SimObject_getFieldValue(_mSimObjectId, fieldName, index);
}
/// <summary>
/// Returns the filename the object is attached to.
///    @return The name of the file the object is associated with; usually the file the object was loaded from. )
/// 
/// </summary>
public  string getFilename(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getFilename(_mSimObjectId);
}
/// <summary>
/// Get the name of the superclass namespace assigned to this object.
///    @return The name of the 'superClass' namespace. )
/// 
/// </summary>
public  string getSuperClassNamespace(){
return TorqueScriptTemplate.m_ts.fn_SimObject_getSuperClassNamespace(_mSimObjectId);
}
/// <summary>
/// Get whether the object has been marked as expanded. (in editor)
///    @return True if the object is marked expanded. )
/// 
/// </summary>
public  bool isExpanded(){
return TorqueScriptTemplate.m_ts.fn_SimObject_isExpanded(_mSimObjectId);
}
/// <summary>
/// Test whether the given field is defined on this object.
///    @param fieldName The name of the field.
///    @return True if the object implements the given field. )
/// 
/// </summary>
public  bool isField(string fieldName){
return TorqueScriptTemplate.m_ts.fn_SimObject_isField(_mSimObjectId, fieldName);
}
/// <summary>
/// Test whether the namespace of this object is a direct or indirect child to the given namespace.
///    @param name The name of a namespace.
///    @return True if the given namespace name is within the namespace hierarchy of this object. )
/// 
/// </summary>
public  bool isInNamespaceHierarchy(string name){
return TorqueScriptTemplate.m_ts.fn_SimObject_isInNamespaceHierarchy(_mSimObjectId, name);
}
/// <summary>
/// Test whether this object is a member of the specified class.
///    @param className Name of a native C++ class.
///    @return True if this object is an instance of the given C++ class or any of its super classes. )
/// 
/// </summary>
public  bool isMemberOfClass(string className){
return TorqueScriptTemplate.m_ts.fn_SimObject_isMemberOfClass(_mSimObjectId, className);
}
/// <summary>
/// Test whether the given method is defined on this object.
///    @param The name of the method.
///    @return True if the object implements the given method. )
/// 
/// </summary>
public  bool isMethod(string methodName){
return TorqueScriptTemplate.m_ts.fn_SimObject_isMethod(_mSimObjectId, methodName);
}
/// <summary>
///  ),
///    Save out the object to the given file.
///    @param fileName The name of the file to save to.
///    @param selectedOnly If true, only objects marked as selected will be saved out.
///    @param preAppendString Text which will be preprended directly to the object serialization.
///    @param True on success, false on failure. )
/// 
/// </summary>
public  bool save(string fileName, bool selectedOnly, string preAppendString){
return TorqueScriptTemplate.m_ts.fn_SimObject_save(_mSimObjectId, fileName, selectedOnly, preAppendString);
}
/// <summary>
/// Set whether the object will be included in saves.
///    @param value If true, the object will be included in saves; if false, it will be excluded. )
/// 
/// </summary>
public  void setCanSave(bool value){
TorqueScriptTemplate.m_ts.fn_SimObject_setCanSave(_mSimObjectId, value);
}
/// <summary>
/// Assign a class namespace to this object.
///    @param name The name of the 'class' namespace for this object. )
/// 
/// </summary>
public  void setClassNamespace(string name){
TorqueScriptTemplate.m_ts.fn_SimObject_setClassNamespace(_mSimObjectId, name);
}
/// <summary>
/// Set the console type code for the given field.
///    @param fieldName The name of the dynamic field to change to type for.
///    @param type The name of the console type.
///    @note This only works for dynamic fields.  Types of static fields cannot be changed. )
/// 
/// </summary>
public  void setFieldType(string fieldName, string type){
TorqueScriptTemplate.m_ts.fn_SimObject_setFieldType(_mSimObjectId, fieldName, type);
}
/// <summary>
/// Set the value of the given field on this object.
///    @param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
///    @param value The new value to assign to the field.
///    @param index Optional argument to specify an index for an array field.
///    @return True. )
/// 
/// </summary>
public  bool setFieldValue(string fieldName, string value, int index){
return TorqueScriptTemplate.m_ts.fn_SimObject_setFieldValue(_mSimObjectId, fieldName, value, index);
}
/// <summary>
/// Sets the object's file name and path
///    @param fileName The name of the file to associate this object with. )
/// 
/// </summary>
public  void setFilename(string fileName){
TorqueScriptTemplate.m_ts.fn_SimObject_setFilename(_mSimObjectId, fileName);
}
/// <summary>
/// Set whether the object has been marked as expanded. (in editor)
///    @param state True if the object is to be marked expanded; false if not. )
/// 
/// </summary>
public  void setIsExpanded(bool state){
TorqueScriptTemplate.m_ts.fn_SimObject_setIsExpanded(_mSimObjectId, state);
}
/// <summary>
/// Assign a superclass namespace to this object.
///    @param name The name of the 'superClass' namespace for this object. )
/// 
/// </summary>
public  void setSuperClassNamespace(string name){
TorqueScriptTemplate.m_ts.fn_SimObject_setSuperClassNamespace(_mSimObjectId, name);
}
/// <summary>
/// Assign a persistent ID to the object if it does not already have one. )
/// 
/// </summary>
public  void assignPersistentId(){
TorqueScriptTemplate.m_ts.fnSimObject_assignPersistentId(_mSimObjectId);
}
/// <summary>
/// ( SimObject, call, const char*, 3, 0, ( string method, string args... ) Dynamically call a method on an object.
///    @param method Name of method to call.
///    @param args Zero or more arguments for the method.
///    @return The result of the method call. )
/// 
/// </summary>
public  string call(string a2, string a3= "", string a4= "", string a5= "", string a6= "", string a7= "", string a8= "", string a9= "", string a10= "", string a11= "", string a12= "", string a13= "", string a14= "", string a15= "", string a16= "", string a17= "", string a18= "", string a19= ""){
return TorqueScriptTemplate.m_ts.fnSimObject_call(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}
/// <summary>
/// Create a copy of this object.
///    @return An exact duplicate of this object. )
/// 
/// </summary>
public  string clone(){
return TorqueScriptTemplate.m_ts.fnSimObject_clone(_mSimObjectId);
}
/// <summary>
/// Create a copy of this object and all its subobjects.
///    @return An exact duplicate of this object and all objects it references. )
/// 
/// </summary>
public  string deepClone(){
return TorqueScriptTemplate.m_ts.fnSimObject_deepClone(_mSimObjectId);
}
/// <summary>
/// Dump a description of all fields and methods defined on this object to the console.
///    @param detailed Whether to print detailed information about members. )
/// 
/// </summary>
public  void dump(bool detailed){
TorqueScriptTemplate.m_ts.fnSimObject_dump(_mSimObjectId, detailed);
}
/// <summary>
/// Dump the hierarchy of this object up to RootGroup to the console. )
/// 
/// </summary>
public  void dumpGroupHierarchy(){
TorqueScriptTemplate.m_ts.fnSimObject_dumpGroupHierarchy(_mSimObjectId);
}
/// <summary>
/// Return some behind-the-scenes information on the object.
///    @return An ArrayObject filled with internal information about the object. )
/// 
/// </summary>
public  string getDebugInfo(){
return TorqueScriptTemplate.m_ts.fnSimObject_getDebugInfo(_mSimObjectId);
}
/// <summary>
/// Get the group that this object is contained in.
///    @note If not assigned to particular SimGroup, an object belongs to RootGroup.
///    @return The SimGroup object to which the object belongs. )
/// 
/// </summary>
public  string getGroup(){
return TorqueScriptTemplate.m_ts.fnSimObject_getGroup(_mSimObjectId);
}
/// <summary>
/// Get the underlying unique numeric ID of the object.
///    @note Object IDs are unique only during single engine runs.
///    @return The unique numeric ID of the object. )
/// 
/// </summary>
public  int getId(){
return TorqueScriptTemplate.m_ts.fnSimObject_getId(_mSimObjectId);
}
/// <summary>
/// Get the internal name of the object.
///    @return The internal name of the object. )
/// 
/// </summary>
public  string getInternalName(){
return TorqueScriptTemplate.m_ts.fnSimObject_getInternalName(_mSimObjectId);
}
/// <summary>
/// Get the global name of the object.
///    @return The global name assigned to the object. )
/// 
/// </summary>
public  string getName(){
return TorqueScriptTemplate.m_ts.fnSimObject_getName(_mSimObjectId);
}
/// <summary>
/// Test whether the object belongs directly or indirectly to the given group.
///    @param group The SimGroup object.
///    @return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to. )
/// 
/// </summary>
public  bool isChildOfGroup(string group){
return TorqueScriptTemplate.m_ts.fnSimObject_isChildOfGroup(_mSimObjectId, group);
}
/// <summary>
/// Return true if the object is only used by the editor.
///    @return True if this object exists only for the sake of editing. )
/// 
/// </summary>
public  bool isEditorOnly(){
return TorqueScriptTemplate.m_ts.fnSimObject_isEditorOnly(_mSimObjectId);
}
/// <summary>
/// Get whether this object may be renamed.
///    @return True if this object can be renamed; false otherwise. )
/// 
/// </summary>
public  bool isNameChangeAllowed(){
return TorqueScriptTemplate.m_ts.fnSimObject_isNameChangeAllowed(_mSimObjectId);
}
/// <summary>
/// Get whether the object has been marked as selected. (in editor)
///    @return True if the object is currently selected. )
/// 
/// </summary>
public  bool isSelected(){
return TorqueScriptTemplate.m_ts.fnSimObject_isSelected(_mSimObjectId);
}
/// <summary>
/// ( SimObject,schedule, S32, 4, 0, ( float time, string method, string args... ) Delay an invocation of a method.
///    @param time The number of milliseconds after which to invoke the method.  This is a soft limit.
///    @param method The method to call.
///    @param args The arguments with which to call the method.
///    @return The numeric ID of the created schedule.  Can be used to cancel the call. )
/// 
/// </summary>
public  int schedule(string a2, string a3, string a4= "", string a5= "", string a6= "", string a7= "", string a8= "", string a9= "", string a10= "", string a11= "", string a12= "", string a13= "", string a14= "", string a15= "", string a16= "", string a17= "", string a18= "", string a19= ""){
return TorqueScriptTemplate.m_ts.fnSimObject_schedule(_mSimObjectId, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}
/// <summary>
/// Set/clear the editor-only flag on this object.
///    @param value If true, the object is marked as existing only for the editor. )
/// 
/// </summary>
public  void setEditorOnly(bool value){
TorqueScriptTemplate.m_ts.fnSimObject_setEditorOnly(_mSimObjectId, value);
}
/// <summary>
/// Hide/unhide the object.
///    @param value If true, the object will be hidden; if false, the object will be unhidden. )
/// 
/// </summary>
public  void setHidden(bool value){
TorqueScriptTemplate.m_ts.fnSimObject_setHidden(_mSimObjectId, value);
}
/// <summary>
/// Set the internal name of the object.
///    @param newInternalName The new internal name for the object. )
/// 
/// </summary>
public  void setInternalName(string newInternalName){
TorqueScriptTemplate.m_ts.fnSimObject_setInternalName(_mSimObjectId, newInternalName);
}
/// <summary>
/// Set whether the object has been marked as selected. (in editor)
///    @param state True if object is to be marked selected; false if not. )
/// 
/// </summary>
public  void setIsSelected(bool state){
TorqueScriptTemplate.m_ts.fnSimObject_setIsSelected(_mSimObjectId, state);
}
/// <summary>
/// Lock/unlock the object in the editor.
///    @param value If true, the object will be locked; if false, the object will be unlocked. )
/// 
/// </summary>
public  void setLocked(bool value){
TorqueScriptTemplate.m_ts.fnSimObject_setLocked(_mSimObjectId, value);
}
/// <summary>
/// Set the global name of the object.
///    @param newName The new global name to assign to the object.
///    @note If name changing is disallowed on the object, the method will fail with a console error. )
/// 
/// </summary>
public  void setName(string newName){
TorqueScriptTemplate.m_ts.fnSimObject_setName(_mSimObjectId, newName);
}
/// <summary>
/// Set whether this object can be renamed from its first name.
///    @param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error. )
/// 
/// </summary>
public  void setNameChangeAllowed(bool value){
TorqueScriptTemplate.m_ts.fnSimObject_setNameChangeAllowed(_mSimObjectId, value);
}
}}
