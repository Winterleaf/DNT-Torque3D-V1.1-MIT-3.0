// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using WinterLeaf.Classes;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Client
    {
    public partial class Main : TorqueScriptTemplate
        {
        //-----------------------------------------------------------------------------
        //    Source groups.
        //-----------------------------------------------------------------------------
        [Torque_Decorations.TorqueCallBack("", "", "Initialize_Audio", "", 0, 21000, true)]
        public void Initialize_Audio()
            {
            new TorqueSingleton("SFXDescription", "AudioMaster").Create();
            TorqueSingleton ts = new TorqueSingleton("SFXSource", "AudioChannelMaster");
            ts.Props.Add("description", "AudioMaster");
            ts.Create();

            ts = new TorqueSingleton("SFXDescription", "AudioChannel");
            ts.Props.Add("sourceGroup", "AudioChannelMaster");
            ts.Create();

            ts = new TorqueSingleton("SFXSource", "AudioChannelDefault");
            ts.Props.Add("description", "AudioChannel");
            ts.Create();

            ts = new TorqueSingleton("SFXSource", "AudioChannelGui");
            ts.Props.Add("description", "AudioChannel");
            ts.Create();

            ts = new TorqueSingleton("SFXSource", "AudioChannelEffects");
            ts.Props.Add("description", "AudioChannel");
            ts.Create();

            ts = new TorqueSingleton("SFXSource", "AudioChannelMessages");
            ts.Props.Add("description", "AudioChannel");
            ts.Create();

            ts = new TorqueSingleton("SFXSource", "AudioChannelMusic");
            ts.Props.Add("description", "AudioChannel");
            ts.Create();

            ((coSFXSource)"AudioChannelMaster").play(-1);
            ((coSFXSource)"AudioChannelDefault").play(-1);
            ((coSFXSource)"AudioChannelGui").play(-1);
            ((coSFXSource)"AudioChannelMusic").play(-1);
            ((coSFXSource)"AudioChannelMessages").play(-1);
            ((coSFXSource)"AudioChannelEffects").stop(-1);


            //SFXSource.play("AudioChannelMaster", -1);
            //SFXSource.play("AudioChannelDefault", -1);
            //SFXSource.play("AudioChannelGui", -1);
            //SFXSource.play("AudioChannelMusic", -1);
            //SFXSource.play("AudioChannelMessages", -1);

            //SFXSource.stop("AudioChannelEffects", -1);
            //-----------------------------------------------------------------------------
            //    Master SFXDescriptions.
            //-----------------------------------------------------------------------------

            // Master description for interface audio.
            ts = new TorqueSingleton("SFXDescription", "AudioGui");
            ts.Props.Add("volume", "1.0");
            ts.Props.Add("sourceGroup", "AudioChannelGui");
            ts.Create();


            ts = new TorqueSingleton("SFXDescription", "AudioEffect");
            ts.Props.Add("volume", "1.0");
            ts.Props.Add("sourceGroup", "AudioChannelEffects");
            ts.Create();

            ts = new TorqueSingleton("SFXDescription", "AudioMessage");
            ts.Props.Add("volume", "1.0");
            ts.Props.Add("sourceGroup", "AudioChannelMessages");
            ts.Create();

            ts = new TorqueSingleton("SFXDescription", "AudioMusic");
            ts.Props.Add("volume", "1.0");
            ts.Props.Add("sourceGroup", "AudioChannelMusic");
            ts.Create();

            iGlobal["$GuiAudioType"] = 1;
            iGlobal["$SimAudioType"] = 2;
            iGlobal["$MessageAudioType"] = 3;
            iGlobal["$MusicAudioType"] = 4;
            sGlobal["$AudioChannels[0]"] = "AudioChannelDefault";
            sGlobal["$AudioChannels[1]"] = "AudioChannelGui";
            sGlobal["$AudioChannels[2]"] = "AudioChannelEffects";
            sGlobal["$AudioChannels[3]"] = "AudioChannelMessages";
            sGlobal["$AudioChannels[4]"] = "AudioChannelMusic";
            new TorqueSingleton("SimSet", "SFXPausedSet").Create();
            }

        //-----------------------------------------------------------------------------
        //    SFX Functions.
        //-----------------------------------------------------------------------------

        /// This initializes the sound system device from
        /// the defaults in the $pref::SFX:: globals.
        [Torque_Decorations.TorqueCallBack("", "", "sfxStartup", "", 0, 21000, false)]
        public void sfxStartup()
            {
            // The console builds should re-detect, by default, so that it plays nicely 
            // along side a PC build in the same script directory.
            //if (console.GetVarString("$platform") == "xenon")
            //    {
            //    if (console.GetVarString("$pref::SFX::provider") == "DirectSound" || console.GetVarString("$pref::SFX::provider") == "OpenAL")
            //        console.SetVar("$pref::SFX::provider", "");
            //    if (console.GetVarString("$pref::SFX::provider") == "")
            //        {
            //        console.SetVar("$pref::SFX::autoDetect", 1);
            //        console.warn("Xbox360 is auto-detecting available sound providers...");
            //        console.warn("   - You may wish to alter this functionality before release (core/scripts/client/audio.cs)");
            //        }
            //    }
            console.print("sfxStartup...");
            // If we have a provider set, try initialize a device now.

            if (sGlobal["$pref::SFX::provider"] == "")
                {
                if (sfxInit())
                    return;
                else
                    {
                    // Force auto-detection.
                    bGlobal["$pref::SFX::autoDetect"] = true;
                    if (sfxAutodetect())
                        return;
                    }
                }
            else
                {
                bGlobal["$pref::SFX::autoDetect"] = true;
                if (sfxAutodetect())
                    return;
                }
            // Failure.
            console.error("Failed to initialize device!\n\n");
            sGlobal["$pref::SFX::provider"] = "";
            sGlobal["$pref::SFX::device"] = "";
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxInit", "", 0, 21000, false)]
        public bool sfxInit()
            {
            // This initializes the sound system device from
            // the defaults in the $pref::SFX:: globals.
            // If already initialized, shut down the current device first.
            if (Util.sfxGetDeviceInfo() != "")
                sfxShutdown();
            // Start it up!

            int maxBuffers = bGlobal["$pref::SFX::useHardware"] ? -1 : iGlobal["$pref::SFX::maxSoftwareBuffers"];
            if (!Util.sfxCreateDevice(sGlobal["$pref::SFX::provider"], sGlobal["$pref::SFX::device"], bGlobal["$pref::SFX::useHardware"], maxBuffers))
                return false;

            // This returns a tab seperated string with
            // the initialized system info.
            string info = Util.sfxGetDeviceInfo();
            sGlobal["$pref::SFX::provider"] = Util.getField(info, 0);
            sGlobal["$pref::SFX::device"] = Util.getField(info, 1);
            sGlobal["$pref::SFX::useHardware"] = Util.getField(info, 2);


            string useHardware = bGlobal["$pref::SFX::useHardware"] ? "Yes" : "No";
            maxBuffers = Util.getField(info, 3).AsInt();

            console.print("   Provider: " + console.GetVarString("$pref::SFX::provider"));
            console.print("   Device: " + console.GetVarString("$pref::SFX::device"));
            console.print("   Hardware: " + useHardware);
            console.print("   Buffers: " + maxBuffers.AsString());


            if (isGlobal["$pref::SFX::distanceModel"])
                {
                SFXDistanceModel t;
                if (Enum.TryParse(sGlobal["$pref::SFX::distanceModel"], out t))
                    {
                    Util.sfxSetDistanceModel(t);
                    }
                }
            if (isGlobal["$pref::SFX::dopplerFactor"])
                {
                Util.sfxSetDopplerFactor(fGlobal["$pref::SFX::dopplerFactor"]);
                }

            if (Util._isDefined("$pref::SFX::rolloffFactor"))
                {
                Util.sfxSetRolloffFactor(fGlobal["$pref::SFX::rolloffFactor"]);
                }
            // Restore master volume.

            sfxSetMasterVolume(fGlobal["$pref::SFX::masterVolume"]);


            // Restore channel volumes.
            for (int channel = 0; channel <= 8; channel++)
                sfxSetChannelVolume(((coSimSet)channel), fGlobal["$pref::SFX::channelVolume[" + channel.AsString() + "]"]);
            return true;
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxShutdown", "", 0, 21000, false)]
        public void sfxShutdown()
            {
            fGlobal["$pref::SFX::masterVolume"] = sfxGetMasterVolume();

            for (int channel = 0; channel <= 8; channel++)
                sGlobal["$pref::SFX::channelVolume[" + channel.AsString() + "]"] = console.Call("sfxGetChannelVolume", new[] { channel.AsString() });

            // We're assuming here that a null info 
            // string means that no device is loaded.
            if (Util.sfxGetDeviceInfo() == "")
                return;
            Util.sfxDeleteDevice();
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxCompareProvider", "(%providerA, %providerB)", 2, 21000, false)]
        public string sfxCompareProvider(string providerA, string providerB)
            {
            if (providerA == providerB)
                return "0";
            switch (providerA)
                {
                // Always prefer FMOD over anything else.
                case "FMOD":
                    return "1";
                // Prefer OpenAL over anything but FMOD.
                case "OpenAL":
                    return providerB == "FMOD" ? "-1" : "1";
                // As long as the XAudio SFX provider still has issues,
                // choose stable DSound over it.
                case "DirectSound":
                    return providerB == "FMOD" || providerB == "OpenAL" ? "-1" : "0";
                case "XAudio":
                    return providerB == "FMOD" && providerB != "OpenAL" && providerB != "DirectSound" ? "1" : "-1";
                default:
                    return "-1";
                }
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxAutodetect", "()", 0, 21000, false)]
        public bool sfxAutodetect()
            {
            // Get all the available devices.
            string devices = Util.sfxGetAvailableDevices();
            // Collect and sort the devices by preferentiality.


            int count = Util.getRecordCount(devices);


            coArrayObject deviceTrySequence = new Torque_Class_Helper("ArrayObject").Create().AsString();


            for (int i = 0; i < count; i++)
                {
                string info = Util.getRecord(devices, i);
                string provider = Util.getField(info, 0);
                deviceTrySequence.push_back(provider, info);
                }
            deviceTrySequence.sortfk("sfxCompareProvider");
            // Try the devices in order.

            count = deviceTrySequence.count();
            for (int i = 0; i < count; i++)
                {
                string provider = deviceTrySequence.getKey(i);
                string info = deviceTrySequence.getValue(i);
                sGlobal["$pref::SFX::provider"] = provider;
                sGlobal["$pref::SFX::device"] = Util.getField(info, 1);
                sGlobal["$pref::SFX::useHardware"] = Util.getField(info, 2);
                // By default we've decided to avoid hardware devices as
                // they are buggy and prone to problems.
                bGlobal["$pref::SFX::useHardware"] = false;
                if (!sfxInit())
                    continue;
                bGlobal["$pref::SFX::autoDetect"] = false;
                deviceTrySequence.delete();
                return true;
                }
            // Found no suitable device.
            console.error("sfxAutodetect - Could not initialize a valid SFX device.");
            sGlobal["$pref::SFX::provider"] = "";
            sGlobal["$pref::SFX::device"] = "";
            sGlobal["$pref::SFX::useHardware"] = "";
            deviceTrySequence.delete();
            return false;
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxOldChannelToGroup", "(%channel)", 1, 21000, false)]
        public coSFXSource sfxOldChannelToGroup(coSimSet channel)
            {
            return sGlobal["$AudioChannels[" + channel + "]"];
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxGroupToOldChannel", "(%group)", 1, 21000, false)]
        public string sfxGroupToOldChannel(string group)
            {
            string id = console.GetObjectID(group).AsString();
            for (int i = 0; ; i++)
                if (!isGlobal["$AudioChannels[" + i.AsString() + "]"])
                    return "-1";
                else if (sGlobal["$AudioChannels[" + i.AsString() + "]"] == id)
                    return i.AsString();
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxSetMasterVolume", "(%volume)", 1, 21000, false)]
        public void sfxSetMasterVolume(float volume)
            {
            ((coSFXSource)"AudioChannelMaster").setVolume(volume);
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxGetMasterVolume", "()", 0, 21000, false)]
        public float sfxGetMasterVolume()
            {
            //return SFXSource.getVolume("AudioChannelMaster").AsString();
            return ((coSFXSource)"AudioChannelMaster").getVolume();
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxStopAll", "(%channel)", 1, 21000, false)]
        public void sfxStopAll(coSimSet channel)
            {
            channel = sfxOldChannelToGroup(channel);

            if (!channel.isObject())
                return;

            for (uint i = 0; i < channel.getCount(); i++)
                ((coSFXSource)channel.getObject(i)).stop(-1);
            //SFXSource.stop(channel.getObject(i), -1);
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxGetChannelVolume", "(%channel)", 1, 21000, false)]
        public string sfxGetChannelVolume(coSimSet channel)
            {
            coSFXSource obj = sfxOldChannelToGroup(channel);
            return obj.isObject() ? obj.getVolume().AsString() : "0";
            }

        [Torque_Decorations.TorqueCallBack("", "", "sfxSetChannelVolume", "(%channel,%volume)", 2, 21000, false)]
        public void sfxSetChannelVolume(coSimSet channel, float volume)
            {
            coSFXSource obj = sfxOldChannelToGroup(channel);
            if (obj.isObject())
                obj.setVolume(volume);
            }

        /// Pauses the playback of active sound sources.
        /// 
        /// @param %channels    An optional word list of channel indices or an empty 
        ///                     string to pause sources on all channels.
        /// @param %pauseSet    An optional SimSet which is filled with the paused 
        ///                     sources.  If not specified the global SfxSourceGroup 
        ///                     is used.
        ///
        /// @deprecated
        ///
        [Torque_Decorations.TorqueCallBack("", "", "sfxPause", "(%channels, %pauseSet)", 2, 21000, false)]
        public void sfxPause(coSimSet channels, coSimSet pauseSet)
            {
            if (!console.isObject(pauseSet))
                pauseSet = sGlobal["SFXPausedSet"];

            coSimSet SFXSourceSet = sGlobal["SFXSourceSet"];

            for (uint i = 0; i < SFXSourceSet.getCount(); i++)
                {
                coSimObject source = SFXSourceSet.getObject(i);
                string channel = sfxGroupToOldChannel(source.getGroup());

                //console.Call(source, "getGroup"));
                throw new Exception("The find word function doesn't exists... wtf?");
                //if (channel != "" && console.Call("findWord", new string[] { channels, channel }).AsInt() == -1)
                //    continue;
                ////SFXSource.pause(source, -1);
                //pauseSet.pushToBack(source);
                }
            }

        /// Resumes the playback of paused sound sources.
        /// 
        /// @param %pauseSet    An optional SimSet which contains the paused sound 
        ///                     sources to be resumed.  If not specified the global 
        ///                     SfxSourceGroup is used.
        /// @deprecated
        ///
        /// 
        [Torque_Decorations.TorqueCallBack("", "", "sfxResume", "(%pauseSet)", 1, 21000, false)]
        public void sfxResume(coSimSet pauseSet)
            {
            if (!console.isObject(pauseSet))
                pauseSet = sGlobal["SFXPausedSet"];
            for (uint i = 0; i < pauseSet.getCount(); i++)
                ((coSFXSource)pauseSet.getObject(i)).play(-1);
            pauseSet.clear();
            }
        }
    }