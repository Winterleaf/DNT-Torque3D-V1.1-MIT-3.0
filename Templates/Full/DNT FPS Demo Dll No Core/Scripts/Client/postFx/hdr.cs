// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using WinterLeaf.Classes;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Client
    {
    public partial class Main : TorqueScriptTemplate
        {
        [Torque_Decorations.TorqueCallBack("", "", "hdr_Init", "", 0, 99000, true)]
        public void hdr_Init()
            {
            // Blends between the scene and the tone mapped scene.
            sGlobal["$HDRPostFX::enableToneMapping"] = "1.0";

            // The tone mapping middle grey or exposure value used
            // to adjust the overall "balance" of the image.
            //
            // 0.18 is fairly common value.
            //
            //$HDRPostFX::keyValue = 0.18;
            sGlobal["$HDRPostFX::keyValue"] = "0.18";

            // The minimum luninace value to allow when tone mapping 
            // the scene.  Is particularly useful if your scene very 
            // dark or has a black ambient color in places.
            sGlobal["$HDRPostFX::minLuminace"] = "0.001";

            // The lowest luminance value which is mapped to white.  This
            // is usually set to the highest visible luminance in your 
            // scene.  By setting this to smaller values you get a contrast
            // enhancement.
            sGlobal["$HDRPostFX::whiteCutoff"] = "1.0";

            // The rate of adaptation from the previous and new 
            // average scene luminance. 
            sGlobal["$HDRPostFX::adaptRate"] = "2.0";


            // Blends between the scene and the blue shifted version
            // of the scene for a cinematic desaturated night effect.
            sGlobal["$HDRPostFX::enableBlueShift"] = "0.0";

            // The blue shift color value.
            sGlobal["$HDRPostFX::blueShiftColor"] = "1.05 0.97 1.27";


            // Blends between the scene and the bloomed scene.
            sGlobal["$HDRPostFX::enableBloom"] = "1.0";

            // The threshold luminace value for pixels which are
            // considered "bright" and need to be bloomed.

            sGlobal["$HDRPostFX::brightPassThreshold"] = "1.0";

            // These are used in the gaussian blur of the
            // bright pass for the bloom effect.
            sGlobal["$HDRPostFX::gaussMultiplier"] = "0.3";

            sGlobal["$HDRPostFX::gaussMean"] = "0.0";

            sGlobal["$HDRPostFX::gaussStdDev"] = "0.8";


            // The 1x255 color correction ramp texture used
            // by both the HDR shader and the GammaPostFx shader
            // for doing full screen color correction. 

            sGlobal["$HDRPostFX::colorCorrectionRamp"] = default_color_correction;


            TorqueSingleton ts = new TorqueSingleton("ShaderData", "HDR_BrightPassShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/brightPassFilterP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "HDR_DownScale4x4Shader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/hdr/downScale4x4V.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/downScale4x4P.hlsl");
            ts.Props.Add("pixVersion", "2.0");
            ts.Create();


            ts = new TorqueSingleton("ShaderData", "HDR_BloomGaussBlurHShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/bloomGaussBlurHP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();


            ts = new TorqueSingleton("ShaderData", "HDR_BloomGaussBlurVShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/bloomGaussBlurVP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "HDR_SampleLumShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/sampleLumInitialP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "HDR_DownSampleLumShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/sampleLumIterativeP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "HDR_CalcAdaptedLumShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/calculateAdaptedLumP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("ShaderData", "HDR_CombineShader");
            ts.PropsAddString("DXVertexShaderFile", "shaders/common/postFx/postFxV.hlsl");
            ts.PropsAddString("DXPixelShaderFile", "shaders/common/postFx/hdr/finalPassCombineP.hlsl");
            ts.Props.Add("pixVersion", "3.0");
            ts.Create();

            ts = new TorqueSingleton("GFXStateBlockData", "HDR_SampleStateBlock : PFX_DefaultStateBlock");
            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampPoint");
            ts.Props.Add("samplerStates[1]", "SamplerClampPoint");
            ts.Create();

            ts = new TorqueSingleton("GFXStateBlockData", "HDR_DownSampleStateBlock : PFX_DefaultStateBlock");
            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[1]", "SamplerClampLinear");
            ts.Create();


            ts = new TorqueSingleton("GFXStateBlockData", "HDR_CombineStateBlock : PFX_DefaultStateBlock");

            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampPoint");
            ts.Props.Add("samplerStates[1]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[2]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[3]", "SamplerClampLinear");
            ts.Create();


            ts = new TorqueSingleton("GFXStateBlockData", "HDRStateBlock");
            ts.Props.Add("samplersDefined", "true");
            ts.Props.Add("samplerStates[0]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[1]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[2]", "SamplerClampLinear");
            ts.Props.Add("samplerStates[3]", "SamplerClampLinear");

            ts.Props.Add("blendDefined", "true");
            ts.Props.Add("blendDest", "GFXBlendOne");
            ts.Props.Add("blendSrc", "GFXBlendZero");

            ts.Props.Add("zDefined", "true");
            ts.Props.Add("zEnable", "false");
            ts.Props.Add("zWriteEnable", "false");

            ts.Props.Add("cullDefined", "true");
            ts.Props.Add("cullMode", "GFXCullNone");
            ts.Create();
            }

        [Torque_Decorations.TorqueCallBack("", "HDRPostFX", "setShaderConsts", "%this", 1, 99100, false)]
        public void HDRPostFXsetShaderConsts(coPostEffect thisobj)
            {
            thisobj.setShaderConst("$brightPassThreshold", sGlobal["$HDRPostFX::brightPassThreshold"]);
            thisobj.setShaderConst("$g_fMiddleGray", sGlobal["$HDRPostFX::keyValue"]);
            coPostEffect bloomh = thisobj.findObjectByInternalName("bloomH", true);

            bloomh.setShaderConst("$gaussMultiplier", sGlobal["$HDRPostFX::gaussMultiplier"]);
            bloomh.setShaderConst("$gaussMean", sGlobal["$HDRPostFX::gaussMean"]);
            bloomh.setShaderConst("$gaussStdDev", sGlobal["$HDRPostFX::gaussStdDev"]);

            coPostEffect bloomV = thisobj.findObjectByInternalName("bloomV", true);

            bloomV.setShaderConst("$gaussMultiplier", sGlobal["$HDRPostFX::gaussMultiplier"]);
            bloomV.setShaderConst("$gaussMean", sGlobal["$HDRPostFX::gaussMean"]);
            bloomV.setShaderConst("$gaussStdDev", sGlobal["$HDRPostFX::gaussStdDev"]);

            double minLuminace = dGlobal["$HDRPostFX::minLuminace"];

            if (minLuminace <= 0.0)
                minLuminace = 0.00001;

            ((coPostEffect)thisobj.findObjectByInternalName("adaptLum", true)).setShaderConst("$g_fMinLuminace", minLuminace.AsString());
            ((coPostEffect)thisobj.findObjectByInternalName("finalLum", true)).setShaderConst("$adaptRate", sGlobal["$HDRPostFX::adaptRate"]);

            coPostEffect combinePass = thisobj.findObjectByInternalName("combinePass", true);
            combinePass.setShaderConst("$g_fEnableToneMapping", sGlobal["$HDRPostFX::enableToneMapping"]);
            combinePass.setShaderConst("$g_fMiddleGray", sGlobal["$HDRPostFX::keyValue"]);

            combinePass.setShaderConst("$g_fBloomScale", sGlobal["$HDRPostFX::enableBloom"]);
            combinePass.setShaderConst("$g_fEnableBlueShift", sGlobal["$HDRPostFX::enableBlueShift"]);
            combinePass.setShaderConst("$g_fBlueShiftColor", sGlobal["$HDRPostFX::blueShiftColor"]);

            float clampedGamma = Util.mClamp(fGlobal["$pref::Video::Gamma"], (float) 0.001, (float) 2.2);
            combinePass.setShaderConst("$g_fOneOverGamma", (1/clampedGamma).AsString());
            float whiteCutoff = fGlobal["$HDRPostFX::whiteCutoff"]*fGlobal["$HDRPostFX::whiteCutoff"]*fGlobal["$HDRPostFX::whiteCutoff"]*fGlobal["$HDRPostFX::whiteCutoff"];
            combinePass.setShaderConst("$g_fWhiteCutoff", whiteCutoff.AsString());
            }

        [Torque_Decorations.TorqueCallBack("", "HDRPostFX", "preProcess", "%this", 1, 99200, false)]
        public void HDRPostFXpreProcess(coSimSet thisobj)
            {
            coPostEffect combinePass = thisobj.findObjectByInternalName("combinePass", true);
            if (combinePass[".texture[3]"] != sGlobal["$HDRPostFX::colorCorrectionRamp"])
                combinePass.setTexture(3, sGlobal["$HDRPostFX::colorCorrectionRamp"]);
            }

        [Torque_Decorations.TorqueCallBack("", "HDRPostFX", "onEnabled", "%this", 1, 99300, false)]
        public bool HDRPostFXonEnabled(string thisobj)
            {
            // We don't allow hdr on OSX yet.
            if (sGlobal["$platform"] == "macos")
                return false;

            // See what HDR format would be best.
            //%format = getBestHDRFormat();
            GFXFormat format = Util.getBestHDRFormat();
            if ((format == GFXFormat.GFXFormat_UNKNOWNSIZE) || (format == GFXFormat.GFXFormatR8G8B8A8))
                // We didn't get a valid HDR format... so fail.
                return false;
            // HDR does it's own gamma calculation so 
            // disable this postFx.

            ((coPostEffect)"GammaPostFX").disable();

            // Set the right global shader define for HDR.
            switch (format)
                {
                    case GFXFormat.GFXFormatR10G10B10A2:
                        Util.addGlobalShaderMacro("TORQUE_HDR_RGB10", "");
                        break;
                    case GFXFormat.GFXFormatR16G16B16A16:
                        Util.addGlobalShaderMacro("TORQUE_HDR_RGB16", "");
                        break;
                }

            console.print("HDR FORMAT: " + format.ToString());
            // Change the format of the offscreen surface
            // to an HDR compatible format.

            (( coSimObject)"AL_FormatToken")["format"] = format.ToString();

            Util.setReflectFormat(format);
            // Reset the light manager which will ensure the new
            // hdr encoding takes effect in all the shaders and
            // that the offscreen surface is enabled.
            Util.resetLightManager();

            return true;
            }

        [Torque_Decorations.TorqueCallBack("", "HDRPostFX", "onDisabled", "%this", 1, 99400, false)]
        public void HDRPostFXonDisabled(string thisobj)
            {
            // Enable a special GammaCorrection PostFX when this is disabled.
            (( coPostEffect)"GammaPostFX").enable();

            //%format = "GFXFormatR8G8B8A8";
            //AL_FormatToken.format = %format;
            ((coSimObject)"AL_FormatToken")["format"] = "GFXFormatR8G8B8A8";

            // Restore the non-HDR offscreen surface format.
            //setReflectFormat( %format );
            Util.setReflectFormat(GFXFormat.GFXFormatR8G8B8A8);

            //removeGlobalShaderMacro( "TORQUE_HDR_RGB10" );
            Util.removeGlobalShaderMacro("TORQUE_HDR_RGB10");

            //removeGlobalShaderMacro( "TORQUE_HDR_RGB16" );
            Util.removeGlobalShaderMacro("TORQUE_HDR_RGB16");

            //resetLightManager();
            Util.resetLightManager();
            }


        [Torque_Decorations.TorqueCallBack("", "", "hdr_Init7", "", 0, 99501, true)]
        public void hdr_Init7()
            {
            console.Eval(@"
singleton PostEffect( HDRPostFX )
{
   isEnabled = false;
   allowReflectPass = false;
   renderTime = ""PFXBeforeBin"";
   renderBin = ""EditorBin"";
   renderPriority = 9999;
   shader = HDR_BrightPassShader;
   stateBlock = HDR_DownSampleStateBlock;
   texture[0] = ""$backBuffer"";
   texture[1] = ""#adaptedLum"";
   target = ""$outTex"";
   targetFormat = ""GFXFormatR16G16B16A16F""; 
   targetScale = ""0.5 0.5"";
   new PostEffect()
      {
         shader = HDR_DownScale4x4Shader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""$outTex"";
         targetFormat = ""GFXFormatR16G16B16A16F"";
         targetScale = ""0.25 0.25"";
      };
   new PostEffect()
      {
         internalName = ""bloomH"";
         shader = HDR_BloomGaussBlurHShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""$outTex"";
         targetFormat = ""GFXFormatR16G16B16A16F"";   
      };
   new PostEffect()
      {
         internalName = ""bloomV"";
         shader = HDR_BloomGaussBlurVShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""#bloomFinal"";
         targetFormat = ""GFXFormatR16G16B16A16F"";    
      };
   new PostEffect()
      {
      internalName = ""adaptLum"";
      shader = HDR_SampleLumShader;
      stateBlock = HDR_DownSampleStateBlock;
      texture[0] = ""$backBuffer"";
      target = ""$outTex"";
      targetScale = ""0.0625 0.0625"";
      targetFormat = ""GFXFormatR16F"";
      new PostEffect()
         {
         shader = HDR_DownSampleLumShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""$outTex"";
         targetScale = ""0.25 0.25"";
         targetFormat = ""GFXFormatR16F"";
         };
      new PostEffect()
         {
         shader = HDR_DownSampleLumShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""$outTex"";
         targetScale = ""0.25 0.25"";
         targetFormat = ""GFXFormatR16F"";
         };
      new PostEffect()
         {
         shader = HDR_DownSampleLumShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         target = ""$outTex"";
         targetScale = ""0.25 0.25"";
         targetFormat = ""GFXFormatR16F"";
         };
      new PostEffect()
         {
         internalName = ""finalLum"";         
         shader = HDR_CalcAdaptedLumShader;
         stateBlock = HDR_DownSampleStateBlock;
         texture[0] = ""$inTex"";
         texture[1] = ""#adaptedLum"";
         target = ""#adaptedLum"";
         targetFormat = ""GFXFormatR16F"";
         targetClear = ""PFXTargetClear_OnCreate"";
         targetClearColor = ""1 1 1 1"";
         };
   };
   new PostEffect()
   {
      internalName = ""combinePass"";
      shader = HDR_CombineShader;
      stateBlock = HDR_CombineStateBlock;
      texture[0] = ""$backBuffer"";
      texture[1] = ""#adaptedLum"";            
      texture[2] = ""#bloomFinal"";
      texture[3] = ""$HDRPostFX::colorCorrectionRamp"";" + @"

      target = ""$backBuffer"";
   };
};

");
            }


        [Torque_Decorations.TorqueCallBack("", "LuminanceVisPostFX", "setShaderConsts", "%this", 1, 99505, false)]
        public void LuminanceVisPostFXsetShaderConsts(coPostEffect thisobj)
            {
            thisobj.setShaderConst("$brightPassThreshold", sGlobal["$HDRPostFX::brightPassThreshold"]);
            }

        [Torque_Decorations.TorqueCallBack("", "", "hdr_Init_3", "%this", 0, 99502, true)]
        public void hdr_Init_3()
            {
            TorqueSingleton ts = new TorqueSingleton("PostEffect", "LuminanceVisPostFX");
            ts.Props.Add("isEnabled", "false");
            ts.Props.Add("allowReflectPass", "false");
            ts.PropsAddString("renderTime", "PFXBeforeBin");
            ts.PropsAddString("renderBin", "EditorBin");
            ts.Props.Add("renderPriority", "9999");
            ts.Props.Add("shader", "LuminanceVisShader");
            ts.Props.Add("stateBlock", "LuminanceVisStateBlock");
            ts.PropsAddString("texture[0]", "$backBuffer");
            ts.PropsAddString("target", "$backBuffer");
            ts.Create();
            sGlobal["$HDRPostFX::colorCorrectionRamp"] = default_color_correction;
            }

        [Torque_Decorations.TorqueCallBack("", "LuminanceVisPostFX", "onEnabled", "%this", 1, 99600, false)]
        public bool LuminanceVisPostFXonEnabled(string thisobj)
            {
            coPostEffect HDRPostFX = "HDRPostFX";
            if (!HDRPostFX.isEnabledX())
                HDRPostFX.enable();
            HDRPostFX["skip"] = true.AsString();
            return true;
            }

        [Torque_Decorations.TorqueCallBack("", "LuminanceVisPostFX", "onDisabled", "%this", 1, 99700, false)]
        public void LuminanceVisPostFXonDisabled(string thisobj)
            {
            coPostEffect HDRPostFX = "HDRPostFX";
            HDRPostFX["skip"] = false.AsString();
            }
        }
    }