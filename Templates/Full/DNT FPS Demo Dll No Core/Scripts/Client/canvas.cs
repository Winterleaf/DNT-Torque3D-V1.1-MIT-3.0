// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using WinterLeaf.Classes;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Client
    {
    public partial class Main : TorqueScriptTemplate
        {
        public bool canvasCreated;

        [Torque_Decorations.TorqueCallBack("", "", "Initialize_Canvas", "", 0, 22000, true)]
        public void Initialize_Canvas()
            {
            //console.SetVar("$canvasCreated", false);
            canvasCreated = false;
            }

        [Torque_Decorations.TorqueCallBack("", "", "configureCanvas", "", 0, 22000, false)]
        public void configureCanvas()
            {
            coGuiCanvas canvas = "Canvas";

            // Setup a good default if we don't have one already.
            if (sGlobal["$pref::Video::mode"] == "")
                sGlobal["$pref::Video::mode"] = "800 600 false 32 60 0";


            string data = sGlobal["$pref::Video::mode"];
            string resX = Util.getWord(data, iGlobal["$WORD::RES_X"]);
            string resY = Util.getWord(data, iGlobal["$WORD::RES_Y"]);
            string fs = Util.getWord(data, iGlobal["$WORD::FULLSCREEN"]);
            string bpp = Util.getWord(data, iGlobal["$WORD::BITDEPTH"]);
            string rate = Util.getWord(data, iGlobal["$WORD::REFRESH"]);
            string fsaa = Util.getWord(data, iGlobal["$WORD::AA"]);

            console.print("--------------");
            console.print("Attempting to set resolution to \"" + console.GetVarString("$pref::Video::mode") + "\"");

            string deskRes = Util.getDesktopResolution().AsString();
            string deskResX = Util.getWord(deskRes, iGlobal["$WORD::RES_X"]);
            string deskResY = Util.getWord(deskRes, iGlobal["$WORD::RES_Y"]);
            string deskResBPP = Util.getWord(deskRes, 2);

            // We shouldn't be getting this any more but just in case...
            if (bpp == "Default")
                bpp = deskResBPP;

            // Make sure we are running at a valid resolution
            if (fs == "0" || fs == "false")
                {
                // Windowed mode has to use the same bit depth as the desktop
                bpp = deskResBPP;
                if (resX.AsInt() >= deskResX.AsInt() || resY.AsInt() >= deskResY.AsInt())
                    {
                    console.print("Warning: The requested windowed resolution is equal to or larger than the current desktop resolution. Attempting to find a better resolution");
                    string rescount = ((coGuiCanvas) "Canvas").getModeCount().AsString();
                    for (int i = (rescount.AsInt() - 1); i >= 0; i--)
                        {
                        string testRes = canvas.getMode(i);
                        string testResX = Util.getWord(testRes, iGlobal["$WORD::RES_X"]);
                        string testResY = Util.getWord(testRes, iGlobal["$WORD::RES_Y"]);
                        string testBPP = Util.getWord(testRes, iGlobal["$WORD::BITDEPTH"]);

                        if (testBPP != bpp)
                            continue;

                        if ((testResX.AsInt() >= deskResX.AsInt()) || (testResY.AsInt() >= deskResY.AsInt()))
                            continue;
                        // This will work as our new resolution
                        resX = testResX;
                        resY = testResY;

                        console.warn("Warning: Switching to \"" + resX + " " + resY + " " + bpp + "\"");
                        break;
                        }
                    }
                }
            sGlobal["$pref::Video::mode"] = resX + " " + resY + " " + fs + " " + bpp + " " + rate + " " + fsaa;

            string fsLabel = "";

            if (fs.AsInt() == 1 || fs == "true")
                fsLabel = "Yes";
            else
                fsLabel = "No";

            console.print("Accept Mode: \n" + "--Resolution    : " + resX + " " + resY + "\n" + "--Full Screen   : " + fsLabel + "\n" + "--Bits Per Pixel: " + bpp + "\n" + "--Refresh Rate  : " + rate + "\n" + "--FSAA Level    : " + fsaa + "\n" + "---------------------------");
            // Actually set the new video mode

            canvas.setVideoMode(resX, resY, fs, bpp, rate, fsaa);
            // FXAA piggybacks on the FSAA setting in $pref::Video::mode.

            coPostEffect FXAA_PostEffect = "FXAA_PostEffect";
            if (FXAA_PostEffect.isObject())
                FXAA_PostEffect.isEnabled = fsaa.AsInt() > 0;

            //if (console.isObject("FXAA_PostEffect"))
            //    new coPostEffect("FXAA_PostEffect")["isEnabled"] = (fsaa.AsInt() > 0 ? true.AsString() : false.AsString());

            if (bGlobal["$pref::Video::autoDetect"])
                GraphicsQualityAutodetect();
            }

        [Torque_Decorations.TorqueCallBack("", "", "initializeCanvas", "", 0, 22000, false)]
        public void initializeCanvas()
            {
            // Don't duplicate the canvas.
            if (canvasCreated)
                {
                console.error("Cannot instantiate more than one canvas!");
                return;
                }
            if (!console.Call("createCanvas").AsBool())
                {
                console.error("Canvas creation failed. Shutting down.");
                Util.quit();
                }
            canvasCreated = true;
            }

        //---------------------------------------------------------------------------------------------
        // resetCanvas
        // Forces the canvas to redraw itself.
        //---------------------------------------------------------------------------------------------
        [Torque_Decorations.TorqueCallBack("", "", "resetCanvas", "", 0, 22000, false)]
        public void resetCanvas()
            {
            coGuiCanvas Canvas = "Canvas";
            if (Canvas.isObject())
                Canvas.repaint(0);
            //if (console.isObject("Canvas"))
            //    ((coGuiCanvas) "Canvas").repaint(0);
            }

        //---------------------------------------------------------------------------------------------
        // Callbacks for window events.
        //---------------------------------------------------------------------------------------------
        [Torque_Decorations.TorqueCallBack("", "GuiCanvas", "onLoseFocus", "(%this)", 1, 22000, false)]
        public void GuiCanvasonLoseFocus(string thisobj)
            {
            }

        //---------------------------------------------------------------------------------------------
        // Full screen handling
        //---------------------------------------------------------------------------------------------
        [Torque_Decorations.TorqueCallBack("", "GuiCanvas", "attemptFullscreenToggle", "(%this)", 1, 22000, false)]
        public void attemptFullscreenToggle(coGuiCanvas thisobj)
            {
            if (EditorIsActive() && !console.Call(thisobj, "isFullScreen").AsBool())
                {
                console.Call("MessageBoxOk", new[] {"Windowed Mode Required", "Please exit the Mission Editor to switch to full screen."});
                return;
                }
            if (GuiEditorIsActive() && !console.Call(thisobj, "isFullScreen").AsBool())
                {
                console.Call("MessageBoxOk", new[] {"Windowed Mode Required", "Please exit the GUI Editor to switch to full screen."});
                return;
                }
            thisobj.toggleFullscreen();
            }
        }
    }