// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Threading;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    //-----------------------------------------------------------------------------
    // AIPlayer callbacks
    // The AIPlayer class implements the following callbacks:
    //
    //    PlayerData::onStop(%this,%obj)
    //    PlayerData::onMove(%this,%obj)
    //    PlayerData::onReachDestination(%this,%obj)
    //    PlayerData::onMoveStuck(%this,%obj)
    //    PlayerData::onTargetEnterLOS(%this,%obj)
    //    PlayerData::onTargetExitLOS(%this,%obj)
    //    PlayerData::onAdd(%this,%obj)
    //
    // Since the AIPlayer doesn't implement it's own datablock, these callbacks
    // all take place in the PlayerData namespace.
    //-----------------------------------------------------------------------------

    //-----------------------------------------------------------------------------
    // Demo Pathed AIPlayer.
    //-----------------------------------------------------------------------------
    public partial class Main : TorqueScriptTemplate
        {



        private readonly ConcurrentList<AIInterval> m_thoughtqueue = new ConcurrentList<AIInterval>();
        private readonly Random r = new Random();
        private int aiscreated;
        private int lastcount;

        public UInt32 AiPlayerAiPlayerSpawn(string name, TransformF spawnpoint)
            {
            Torque_Class_Helper npcScriptObject = new Torque_Class_Helper("AIPlayer", "");
            npcScriptObject.Props.Add("dataBlock", "DemoPlayer");
            npcScriptObject.Props.Add("path", "");
            coAIPlayer npc = npcScriptObject.Create();
            if (npc != 0)
                {
                ((coSimSet)"MissionCleanup").pushToBack(npc);
                npc.setShapeName(name);
                npc.setTransform(spawnpoint);
                //                console.SetVar(npcID.ToString(), 1);
                }
            return npc;
            }

        [Torque_Decorations.TorqueCallBack("", "", "DumpMC", "", 0, 2500, false)]
        public void DumpMC()
            {
            console.error("Items in Missioncleaup are " + ((coSimSet)"MissionCleanup").getCount());
            }


        [Torque_Decorations.TorqueCallBack("", "", "createAI", "(%numofai", 1, 2500, false)]
        public void createAI(int count)
            {
            if (lastcount > 0)
                {
                console.error("Mobs already spawned");
                return;
                }

            lastcount = count;
            int team = 0;
            for (int i = 0; i < count; i++)
                {
                team++;
                if (team == 3)
                    team = 1;

                coScriptObject MobRoot = new Torque_Class_Helper("ScriptObject", "Mob" + i.AsString()).Create().AsString();
                MobRoot["player"] = "";
                MobRoot["aiteam"] = team.AsString();
                ((coSimSet)"rootgroup").pushToBack(MobRoot);
                Util._schedule((i * 100).AsString(), "0", "spawnAI", MobRoot);
                }
            using (BackgroundWorker bwr_AIThought = new BackgroundWorker())
                {
                bwr_AIThought.DoWork += bwr_AIThought_DoWork;

                bwr_AIThought.RunWorkerAsync();
                }
            }

        private void bwr_AIThought_DoWork(object sender, DoWorkEventArgs e)
            {
            while (lastcount > 0 && m_ts.IsRunning)
                {
                List<AIInterval> t = m_thoughtqueue.toArray().Where(item => item.Intervaltime < DateTime.Now).ToList();
                int counter = 0;
                bool nosleep = false;
                lock (m_ts.tick)
                    foreach (AIInterval item in t)
                        {
                        counter++;
                        if (counter > 3)
                            {
                            nosleep = true;
                            break;
                            }
                        m_thoughtqueue.Remove(item);
                        if (console.isObject(item.Player_id))
                            AIPlayerThink(item.Player_id, item.Player_id);
                        }
                if (!nosleep)
                    Thread.Sleep(100);
                else
                    Thread.Sleep(32);
                }
            }

        [Torque_Decorations.TorqueCallBack("", "", "deleteAI", "", 0, 2500, false)]
        public void deleteAI()
            {
            for (int i = 0; i < lastcount; i++)
                {
                coScriptObject mobholder = "Mob" + i.AsString();
                mobholder["player"].delete();
                mobholder.delete();
                }
            lastcount = 0;
            }

        [Torque_Decorations.TorqueCallBack("", "", "spawnAI", "(%this)", 1, 2500, false)]
        public void spawnAI(coScriptObject aiManager)
            {
            if (!console.isObject(aiManager))
                {
                console.error("Bad aiManager!");
                return;
                }

            coAIPlayer aiPlayer = AiPlayerSpawnOnPath("Team" + aiManager["aiteam"], "MissionGroup/Paths/team" + aiManager["aiteam"] + "Path");

            if (aiPlayer == null)
                {
                console.error("UNABLE TO SPAWN MONSTER!@!!!!!a");
                aiManager.schedule("1000", "0", "spawnai", aiManager);
                return;
                }
            if (!console.isObject(aiPlayer))
                {
                console.error("UNABLE TO SPAWN MONSTER!@!!!!!");
                aiManager.schedule("1000", "0", "spawnai", aiManager);
                return;
                }
            //  m_ts.LogError("AIManager " + aiManager + " - Creating.");



            aiPlayer.call("FollowPath", "MissionGroup/Paths/team" + aiManager["aiteam"] + "Path", "-1");
            aiPlayer.setMoveSpeed(0.8f);
            aiManager["player"] = aiPlayer;
            aiPlayer["aiManager"] = aiManager;
            aiPlayer["aiteam"] = aiManager["aiteam"];

            ShapeBaseShapeBaseSetInventory(aiPlayer, "Lurker", 1);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "LurkerClip", 1000);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "LurkerAmmo", 1000);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "LurkerGrenadeLauncher", 1);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "LurkerGrenadeAmmo", 10);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "ProxMine", 5);
            ShapeBaseShapeBaseSetInventory(aiPlayer, "DeployableTurret", 5);


            aiPlayer.mountImage("LurkerWeaponImage", 0, true, "");


            TransformF t = aiPlayer.getTransform();
            t.MPosition.z += r.Next(0, 200);
            aiPlayer.setTransform(t);

            AddObjectTo_MobSearchGroup(aiPlayer, aiManager["aiteam"].AsInt());

            m_thoughtqueue.Add(new AIInterval(DateTime.Now.AddMilliseconds(500), aiPlayer));
            //AIPlayerThink(aiPlayer, aiPlayer);
            //aiPlayer.schedule("100", "think", aiPlayer);
            aiscreated++;
            }

        public void AddObjectTo_MobSearchGroup(coPlayer obj, int team)
            {
            coSimSet MobSearchGroup = "MobSearchGroup_" + team;
            if (!MobSearchGroup.isObject())
                {
                MobSearchGroup = new Torque_Class_Helper("SimSet", "MobSearchGroup_" + team).Create();
                }
            MobSearchGroup.add(obj);
            }



        #region AIPlayer Datablock

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onDisabled", "(%this, %obj, %state)", 3, 2500, false)]
        public void DemoPlayerOnDisabled(coPlayerData datablock, coAIPlayer npc, string state)
            {
            Util._cancelAll(npc);
            coScriptObject aimanager = null;

            aimanager = npc["aiManager"];
            if (!aimanager.isObject())
                {
                console.error("Bad aiManager");
                return;
                }
            npc.setImageTarget(0, false);



            coSimObject item = ((coSimObject)npc.getMountedImage(WeaponSlot))["item"];
            if (item.isObject())
                {
                //string item = console.GetVarString(ShapeBase.getMountedImage(npc, WeaponSlot).AsString() + ".item");
                if (r.Next(1, 100) > 80)
                    {
                    int amount = ShapeBaseShapeBaseGetInventory(npc, item["image.ammo"]);

                    if (amount.AsBool())
                        ShapeBaseShapeBaseThrow(npc, item["image.clip"], 1);
                    }
                }

            ShapeBaseTossPatch(npc);
            PlayerPlayDeathCry(npc);
            PlayerPlayDeathAnimation(npc);
            int ctov = 2000;

            spawnAI(aimanager);

            npc.schedule((ctov - 1000).AsString(), "startFade", "1000", "0", "true");
            npc.schedule(ctov.AsString(), "deleteme");
            aiscreated--;
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "deleteme", "(%this)", 2, 2400, false)]
        public void deleteme(coAIPlayer npc, string t)
            {
            Util._cancelAll(npc);
            npc.delete();
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "damage", "(%this, %obj, %sourceObject, %position, %damage, %damageType)", 6, 2400, false)]
        public void DemoPlayerDamage(coPlayerData datablock, coAIPlayer npc, string position, coPlayer sourceobject, float damage, string damageType)
            {
            if (!npc.isObject())
                return;
            if (npc.getState() == "Dead")
                return;
            if (damage == 0.0)
                return;


            npc.applyDamage(damage);

            if (npc.getState() == "Dead")
                return;

            Point3F ejectvel = npc.getVelocity();

            if (ejectvel.z <= 0)
                {
                ejectvel += new Point3F(0, 0, 5);
                ejectvel = ejectvel.vectorScale(datablock["mass"].AsFloat());
                npc.applyImpulse(npc.getPosition(), ejectvel);
                }


            Point3F currentpos = npc.getPosition();
            currentpos.x += r.Next(-5, 5);
            currentpos.y += r.Next(-5, 5);

            if (npc.getDamageLevel() > 50)
                {
                currentpos.x += r.Next(-50, 50);
                currentpos.y += r.Next(-50, 50);
                }


            npc.setMoveDestination(currentpos, false);
            }


        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onReachDestination", "(%this,%obj)", 2, 2500, false)]
        public void DemoPlayerOnReachDestination(coPlayerData datablock, coAIPlayer npc)
            {
            if (npc["HoldAndFire"].AsBool())
                return;
            if (npc["path"] == "")
                return;
            if (npc["currentNode"] == npc["targetNode"])
                DemoPlayerOnEndOfPath(datablock, npc, npc["path"]);
            else
                AiPlayerMoveToNextNode(npc);
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onMoveStuck", "(%this,%obj)", 2, 2500, false)]
        public void DemoPlayerOnMoveStuck(coPlayerData datablock, coAIPlayer npc)
            {
            coSimSet path = npc["path"];
            uint targetnode = datablock["targetNode"].AsUint();
            coMarker node = path.getObject(targetnode);
            TransformF t = node.getTransform();
            t.MPosition.z += r.Next(10, 100);
            t.MPosition.x += r.Next(10, 30);
            t.MPosition.y += r.Next(10, 30);
            npc.setTransform(t);
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onTargetExitLOS", "(%this,%obj)", 2, 2500, false)]
        public void DemoPlayerOnTargetExitLos(coPlayerData datablock, coAIPlayer npc)
            {
            npc.setImageTrigger(0, false);
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onTargetEnterLOS", "(%this,%obj)", 2, 2500, false)]
        public void DemoPlayerOnTargetEnterLos(coPlayerData datablock, coAIPlayer npc)
            {
            npc.setImageTrigger(0, true);
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onEndOfPath", "(%this,%obj,path)", 3, 2500, false)]
        public void DemoPlayerOnEndOfPath(coPlayerData datablock, coAIPlayer npc, string path)
            {
            AiPlayerNextTask(npc);
            }

        [Torque_Decorations.TorqueCallBack("", "DemoPlayer", "onEndSequence", "(%this,%obj,path)", 3, 2500, false)]
        public void DemoPlayerOnEndSequence(coPlayerData datablock, coAIPlayer npc, int slot)
            {
            npc.stopThread(slot);
            AiPlayerNextTask(npc);
            }

        #endregion

        #region AIPlayer TorqueClass Object

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "spawn", "(%name,%spawnPoint)", 2, 2500, false)]
        public coAIPlayer AiPlayerSpawn(string name, TransformF spawnPoint)
            {
            Torque_Class_Helper tch = new Torque_Class_Helper("AiPlayer");
            tch.Props.Add("dataBlock", "DemoPlayer");
            tch.Props.Add("path", "");
            coAIPlayer npc = tch.Create();
            ((coSimSet)"MissionCleanup").pushToBack(npc);
            npc.setShapeName(name);
            npc.setTransform(spawnPoint);
            return npc;
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "spawnOnPath", "(%name,%path)", 2, 2500, false)]
        public coAIPlayer AiPlayerSpawnOnPath(string ainame, coSimSet path)
            {
            if (!console.isObject(path))
                return null;

            coMarker node = path.getObject((uint)r.Next(0, path.getCount() - 1));

            TransformF transform = node.getTransform();
            return AiPlayerSpawn(ainame, transform);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "followPath", "(%this,%path,%node)", 3, 2500, false)]
        public void AiPlayerFollowPath(coAIPlayer npc, coSimSet path, int node)
            {
            npc.stopThread(0);

            if (!console.isObject(path))
                {
                npc["path"] = "";
                return;
                }

            if (node > path.getCount() - 1)
                npc["targetNode"] = (path.getCount() - 1).AsString();
            else
                npc["targetNode"] = node.AsString();

            if (((coSimSet)npc["path"]) == path)
                AiPlayerMoveToNode(npc, npc["currentNode"].AsUint());

            else
                {
                npc["path"] = path;
                AiPlayerMoveToNode(npc, 0);
                }
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "moveToNextNode", "(%this)", 1, 2500, false)]
        public void AiPlayerMoveToNextNode(coAIPlayer npc)
            {
            uint targetnode = npc["targetNode"].AsUint();
            uint currentnode = npc["currentNode"].AsUint();
            uint pathcount = (uint)((coSimSet)npc["path"]).getCount();
            if ((targetnode < 0) || (currentnode < targetnode))
                AiPlayerMoveToNode(npc, currentnode < pathcount - 1 ? (currentnode + 1) : 0);
            else

                AiPlayerMoveToNode(npc, currentnode == 0 ? (pathcount - 1) : (currentnode - 1));
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "moveToNode", "(%this,%index)", 2, 2500, false)]
        public void AiPlayerMoveToNode(coAIPlayer npc, uint index)
            {
            npc["currentNode"] = index.AsString();
            ((coSimSet)npc["path"]).getObject(index);
            coMarker node = ((coSimSet)npc["path"]).getObject(index);
            if (npc.getMoveDestination() != node.getTransform().MPosition)
                npc.setMoveDestination(node.getTransform().MPosition, false);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "pushTask", "(%this,%method)", 2, 2500, false)]
        public void AiPlayerPushTask(coAIPlayer npc, string method)
            {
            if (npc["taskIndex"] == "")
                {
                npc["taskIndex"] = "0";
                npc["taskCurrent"] = "-1";
                }
            npc["task[" + npc + ".taskIndex]"] = method;
            npc["taskIndex"] = (npc["taskIndex"].AsInt() + 1).AsString();
            if (npc["taskCurrent"].AsInt() != -1)
                return;
            AiPlayerExecuteTask(npc, npc["taskIndex"].AsInt() - 1);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "clearTasks", "(%this)", 1, 2500, false)]
        public void AiPlayerClearTasks(coAIPlayer npc)
            {
            npc["taskIndex"] = "0";
            npc["taskCurrent"] = "-1";
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "nextTask", "(%this)", 1, 2500, false)]
        public void AiPlayerNextTask(coAIPlayer npc)
            {
            if (npc["taskCurrent"].AsInt() == -1)
                return;
            if (npc["taskCurrent"].AsInt() < npc["taskIndex"].AsInt() - 1)
                {
                npc["taskCurrent"] = (npc["taskCurrent"].AsInt() + 1).AsString();
                AiPlayerExecuteTask(npc, npc["taskCurrent"].AsInt());
                }
            else
                npc["taskCurrent"] = "-1";
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "executeTask", "(%this,%index)", 2, 2500, false)]
        public void AiPlayerExecuteTask(coAIPlayer npc, int index)
            {
            npc["taskCurrent"] = index.AsString();
            console.error("This probally doens't work and will need debugging");
            console.Eval(npc[npc["task[" + index + "]"]]);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "singleShot", "(%this)", 1, 2500, false)]
        public void AiPlayerSingleShot(coAIPlayer aiPlayer)
            {
            aiPlayer.setImageTrigger(0, true);
            aiPlayer.setImageTrigger(0, false);
            aiPlayer["trigger"] = aiPlayer.schedule(aiPlayer["shootingDelay,singleShot"], "singleShot", aiPlayer).AsString();
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "wait", "(%this, %time)", 2, 2500, false)]
        public void AiPlayerWait(coAIPlayer npc, string time)
            {
            npc.schedule((time.AsLong() * 1000).AsString(), "nextTask");
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "done", "(%this, %time)", 2, 2500, false)]
        public void AiPlayerDone(coAIPlayer npc, string time)
            {
            npc.schedule("0", "delete");
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "fire", "(%this, %bool)", 2, 2500, false)]
        public void AiPlayerFire(coAIPlayer npc, bool sbool)
            {
            Util._cancel(npc["trigger"]);
            if (sbool)
                AiPlayerSingleShot(npc);
            npc.call("nextTask");
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "aimAt", "(%this, %object)", 2, 2500, false)]
        public void AiPlayerAimAt(coAIPlayer npc, coPlayer target)
            {
            npc.setAimObject(target);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "animate", "(%this,%seq)", 2, 2500, false)]
        public void AiPlayerAnimate(coAIPlayer npc, string seq)
            {
            npc.setActionThread(seq, false, true);
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "getNearestPlayerTarget", "(%this)", 1, 2500, false)]
        public int AIPlayergetNearestPlayerTarget(coAIPlayer npc)
            {
            if (!console.isObject(npc))
                return -1;

            if ((npc["CurrentTarget"] != "") && (npc["CurrentTarget"] != "-1"))
                {
                if (npc["CurrentTarget"].isObject())
                    if (((coPlayer)npc["CurrentTarget"]).getState() != "Dead")
                        return npc["CurrentTarget"].AsInt();
                }


            coSimSet MobSearchGroup;

            if (npc["aiteam"] == "1")
                MobSearchGroup = "MobSearchGroup_2";
            else
                MobSearchGroup = "MobSearchGroup_1";

            coSimSet MobSearchGroupResult = "MobSearchGroupResult";
            if (!MobSearchGroupResult.isObject())
                MobSearchGroupResult = new Torque_Class_Helper("SimSet", "MobSearchGroupResult").Create();

            npc.AISearchSimSet(180, 50, MobSearchGroup, MobSearchGroupResult);


            int closesttarget = -1;
            float closestdist = 51;

            for (uint i = 0; i < MobSearchGroupResult.getCount(); i++)
                {
                coPlayer target = MobSearchGroupResult.getObject(i);
                if (!target.isObject())
                    continue;
                if (target.getState() == "Dead")
                    continue;
                float dist = AIPlayergetTargetDistance(npc, target);
                if (dist >= closestdist)
                    continue;
                closestdist = dist;
                closesttarget = target;
                }
            MobSearchGroupResult.clear();

            npc["CurrentTarget"] = closesttarget.AsString();

            return closesttarget;
            }

        public float AIPlayergetTargetDistance(coAIPlayer npc, coPlayer target)
            {
            return Util.VectorDist(target.getPosition(), npc.getWorldBoxCenter());
            }

        public bool AIPlayerplayerLOS(coAIPlayer npc, coPlayer target)
            {
            const uint mask = (uint)(SceneObjectTypesAsUint.StaticObjectType | SceneObjectTypesAsUint.TerrainObjectType);

            string collision = Util.containerRayCast(npc.getEyePoint(), target.getEyePoint(), mask, npc, true);
            if (collision == "0")
                return true;

            string hit = collision.Split(' ')[0];
            return hit == target;
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "think", "(%this,%t)", 2, 2500, false)]
        public void AIPlayerThink(coAIPlayer npc, coAIPlayer ai)
            {
            if (!npc.isObject())
                return;
            if (npc.getState() == "Dead")
                return;


            int nextdelay = AIPlayerCheckForEnemy(npc) ? 1000 : 750;
            m_thoughtqueue.Add(new AIInterval(DateTime.Now.AddMilliseconds(nextdelay), npc));
            }

        [Torque_Decorations.TorqueCallBack("", "AIPlayer", "CheckForEnemy", "(%this,%t)", 2, 2500, false)]
        public bool AIPlayerCheckForEnemy(coAIPlayer npc)
            {
            if (!npc.isObject())
                return false;
            int nearestplayer = AIPlayergetNearestPlayerTarget(npc);
            if (nearestplayer != -1)
                {
                float dist = AIPlayergetTargetDistance(npc, nearestplayer);
                TransformF t = ((coPlayer)nearestplayer).getTransform();
                if (dist < 30)
                    {

                    npc.setAimObject(nearestplayer.AsString());
                    string currentweapon = ((coSimObject)npc.getMountedImage(0))["name"];

                    if (dist > 25)
                        {
                        if (currentweapon != "LurkerGrenadeLauncherImage")
                            if (ShapeBaseShapeBaseHasInventory(npc, "LurkerGrenadeAmmo"))
                                npc.mountImage("LurkerGrenadeLauncherImage", 0, true, "");
                            else if (currentweapon != "LurkerWeaponImage")
                                npc.mountImage("LurkerWeaponImage", 0, true, "");
                        }
                    else if (dist > 10)
                        {
                        if (currentweapon != "LurkerWeaponImage")
                            npc.mountImage("LurkerWeaponImage", 0, true, "");
                        }
                    else
                        {
                        if (ShapeBaseShapeBaseHasInventory(npc, "ProxMine"))
                            {
                            ShapeBaseShapeBaseThrow(npc, "ProxMine", 1);
                            }
                        if (currentweapon != "LurkerWeaponImage")
                            npc.mountImage("LurkerWeaponImage", 0, true, "");

                        }

                    npc["HoldAndFire"] = true.AsString();

                    if (AIPlayerplayerLOS(npc, nearestplayer))
                        {
                        npc.setImageTrigger(0, true);
                        npc.setImageTrigger(0, false);
                        }
                    else
                        {
                        if (currentweapon == "LurkerGrenadeLauncherImage")
                            {
                            npc.setImageTrigger(0, true);
                            npc.setImageTrigger(0, false);
                            }
                        }

                    if (dist < 10)
                        npc.stop();
                    else
                        npc.setMoveDestination(t.MPosition, false);
                    return false;
                    }

                npc.setMoveDestination(t.MPosition, false);
                return false;


                }
            npc["HoldAndFire"] = false.AsString();

            npc.clearAim();
            AiPlayerMoveToNode(npc, npc["currentNode"].AsUint());
            return true;
            }

        #endregion

        #region Nested type: AIInterval

        private class AIInterval
            {
            private DateTime m_intervaltime;

            private string m_player_id;

            public AIInterval(DateTime dt, string p)
                {
                m_intervaltime = dt;
                m_player_id = p;
                }

            public DateTime Intervaltime
                {
                get { return m_intervaltime; }
                set { m_intervaltime = value; }
                }

            public string Player_id
                {
                get { return m_player_id; }
                set { m_player_id = value; }
                }
            }

        #endregion

        #region Nested type: ConcurrentList

        private class ConcurrentList<T>
            {
            private readonly List<T> m_Objects;
            private readonly object mlock = new object();

            public ConcurrentList()
                {
                m_Objects = new List<T>();
                }

            public void Add(T obj)
                {
                lock (mlock)
                    m_Objects.Add(obj);
                }

            public T[] toArray()
                {
                T[] temp;
                lock (mlock)
                    temp = m_Objects.ToArray();
                return temp;
                }

            public void Remove(T toremove)
                {
                lock (mlock)
                    m_Objects.Remove(toremove);
                }
            }

        #endregion
        }
    }