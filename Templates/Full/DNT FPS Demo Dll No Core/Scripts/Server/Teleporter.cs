// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.Linq;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    //-----------------------------------------------------------------------------
    // Torque
    // Copyright GarageGames, LLC 2011
    //-----------------------------------------------------------------------------

    //-----------------------------------------------------------------------------
    // Trigger-derrived teleporter object. Teleports an object from it's entrance to 
    // it's exit if one is defined.  

    public partial class Main : TorqueScriptTemplate
        {
        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "onAdd", "( %this, %teleporter )", 2, 1800, false)]
        public void TeleporterTriggerOnAdd(coSimDataBlock thisobj, coShapeBase teleporter)
            {
            if (teleporter["exit"] == "")
                teleporter["exit"] = "NameOfTeleporterExit";

            if (teleporter["teleporterCooldown"] == "")
                teleporter["teleporterCooldown"] = thisobj["teleporterCooldown"];

            if (teleporter["exitVelocityScale"] == "")
                teleporter["exitVelocityScale"] = thisobj["exitVelocityScale"];

            if (teleporter["reorientPlayer"] == "")
                teleporter["reorientPlayer"] = thisobj["reorientPlayer"];

            if (teleporter["oneSided"] == "")
                teleporter["oneSided"] = thisobj["oneSided"];

            if (teleporter["entranceEffect"] == "")
                teleporter["entranceEffect"] = thisobj["entranceEffect"];

            if (teleporter["exitEffect"] == "")
                teleporter["exitEffect"] = thisobj["exitEffect"];
            // We do not want to save this variable between levels, 
            // clear it out every time the teleporter is added 
            // to the scene.

            teleporter["timeOfLastTeleport"] = "";
            }

        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "onLeaveTrigger", "(%this,%trigger,%obj)", 3, 1800, false)]
        public void TeleporterTriggerOnLeaveTrigger(coSimDataBlock thisobj, coShapeBase trigger, coShapeBase obj)
            {
            obj["isTeleporting"] = false.AsString();
            }

        //ARGS:
        // %this - The teleporter datablock.
        // %entrance - The teleporter the player has entered (The one calling this function).
        // %obj - The object that entered the teleporter.
        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "onEnterTrigger", "(%this, %entrance, %obj)", 3, 1800, false)]
        public void TeleporterTriggerOnEnterTrigger(coSimDataBlock thisobj, coSceneObject entrance, coPlayer obj)
            {
            //if (!console.isMemberOfClass(obj, "Player"))
            //    return;

            if (obj["isTeleporting"].AsBool())
                return;
            // Get the location of our target position
            coTrigger exit = entrance["exit"];

            bool valid = TeleporterTriggerVerifyObject(thisobj, obj, entrance, exit);
            if (!valid)
                return;

            TeleporterTriggerTeleFrag(thisobj, obj, exit);
            // Create our entrance effects on all clients.



            coSimObject entranceeffect = entrance["entranceEffect"];
            if (entranceeffect.isObject())
                foreach (coGameConnection client in ClientGroup)
                    {
                    if (console.isObject(client))
                        console.commandToClient(client, "PlayTeleportEffect", new[] { entrance["position"], entranceeffect.getId().AsString() });
                    }


            TeleporterTriggerTeleportPlayer(thisobj, obj, exit);
            // Create our exit effects on all clients.

            coSimObject exitEffect = entrance["exitEffect"];
            if (exitEffect.isObject())
                foreach (coGameConnection client in ClientGroup)
                    {
                    if (console.isObject(client))
                        console.commandToClient(client, "PlayTeleportEffect", new[] { entrance["position"], exitEffect.getId().AsString() });
                    }

            // Record what time we last teleported so we can determine if enough
            // time has elapsed to teleport again
            int tolt = console.getSimTime();
            entrance["timeOfLastTeleport"] = tolt.AsString();

            // If this is a bidirectional teleporter, log it's exit too.
            if (exit["exit"] == entrance["name"])
                exit["timeOfLastTeleport"] = tolt.AsString();


            // Tell the client to play the 2D sound for the player that teleported.
            if (((coSimObject)thisobj["teleportSound"]).isObject() && ((coGameConnection)obj["client"]).isObject())
                {
                ((coGameConnection)obj["client"]).play2D(thisobj["teleportSound"]);
                //GameConnection.play2D(obj, thisobj["teleportSound"]);
                }
            }

        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "verifyObject", "(%this, %obj, %entrance, %exit)", 4, 1800, false)]
        public bool TeleporterTriggerVerifyObject(coSimDataBlock thisobj, coShapeBase obj, coSceneObject entrance, coSceneObject exit)
            {
            // Bail out early if we couldn't find an exit for this teleporter.
            if (!exit.isObject())
                {
                console.error(string.Format("Cound not find an exit for {0}", console.GetVarString(entrance + ".name")));
                return false;
                }


            if (!obj.isMemberOfClass("Player"))
                return false;

            // If the entrance is once sided, make sure the object
            // approached it from it's front.
            if (entrance["oneSided"].AsBool())
                {
                TransformF forwardvector = new TransformF(entrance.getForwardVector());

                Point3F velocity = obj.getVelocity();
                float dotProduct = TransformF.vectorDot(forwardvector, velocity);
                if (dotProduct > 0)
                    return false;
                // If we are coming directly from another teleporter and it happens
                // to be bidirectional, We need to avoid ending sending objects through
                // an infinite loop.

                if (obj["isTeleporting"].AsBool())
                    return false;
                // We only want to teleport players
                // So bail out early if we have found any 
                // other object.


                if (entrance["timeOfLastTeleport"].AsInt() > 0 && entrance["teleporterCooldown"].AsInt() > 0)
                    {
                    int currentTime = console.getSimTime();
                    int timedifference = currentTime - entrance["timeOfLastTeleport"].AsInt();
                    coSimDataBlock db = console.getDatablock(entrance);
                    if (timedifference <= db["teleporterCooldown"].AsInt())
                        return false;
                    }
                }
            return true;
            }

        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "teleFrag", "(%this, %player, %exit)", 3, 1800, false)]
        public void TeleporterTriggerTeleFrag(coSimDataBlock thisobj, coPlayer player, coTrigger exit)
            {
            // When a telefrag happens, there are two cases we have to consider.
            // The first case occurs when the player's bounding box is much larger than the exit location, 
            // it is possible to have players colide even though a player is not within the bounds 
            // of the trigger Because of this we first check a radius the size of a player's bounding 
            // box around the exit location.

            // Get the bounding box of the player

            Point3F boundingBoxSize = new Point3F(((coPlayerData)player.getDataBlock())["boundingBox"]);
            float radius = boundingBoxSize.x;
            float boxSizeY = boundingBoxSize.y;
            float boxSizeZ = boundingBoxSize.z;

            // Use the largest dimention as the radius to check
            if (boxSizeY > radius)
                radius = boxSizeY;
            if (boxSizeZ > radius)
                radius = boxSizeZ;

            Point3F position = exit.getTransform().MPosition; // new TransformF(con.getTransform(exit));
            uint mask = (uint)SceneObjectTypesAsUint.PlayerObjectType;

            // Check all objects within the found radius of the exit location, and telefrag
            // any players that meet the conditions.

            Dictionary<uint, float> r = console.initContainerRadiusSearch(position, radius, mask);
            foreach (coShapeBase objectNearExit in r.Keys.Where(objectNearExit => ((coShapeBase)objectNearExit).isMemberOfClass("Player")).Where(objectNearExit => objectNearExit.AsString() != player))
                {
                ShapeBaseDamage(objectNearExit, player, exit.getTransform().MPosition, 10000, "Telefrag");
                }
            // The second case occurs when the bounds of the trigger are much larger
            // than the bounding box of the player. (So multiple players can exist within the
            // same trigger). For this case we check all objects contained within the trigger
            // and telefrag all players.

            int objectsInExit = exit.getNumObjects();
            // Loop through all objects in the teleporter exit
            // And kill any players
            for (int i = 0; i < objectsInExit; i++)
                {
                coShapeBase objectInTeleporter = console.Call(exit, "getObject", new[] { i.AsString() });
                if (objectInTeleporter.isMemberOfClass("Player"))
                    continue;
                // Avoid killing the player that is teleporting in the case of two
                // Teleporters near eachother.
                if (objectInTeleporter == player)
                    continue;

                ShapeBaseDamage(objectInTeleporter, player, exit.getTransform().MPosition, 10000, "Telefrag");
                }
            }

        [Torque_Decorations.TorqueCallBack("", "TeleporterTrigger", "teleportPlayer", "(%this, %player, %exit)", 3, 1800, false)]
        public void TeleporterTriggerTeleportPlayer(coSimDataBlock thisobj, coPlayer player, coSceneObject exit)
            {
            TransformF targetPosition;
            if (exit["reorientPlayer"].AsBool())
                {
                targetPosition = exit.getTransform();
                }
            else
                {
                targetPosition = exit.getTransform();
                TransformF playerrot = player.getTransform();
                targetPosition.MOrientation.x = playerrot.MOrientation.x;
                targetPosition.MOrientation.y = playerrot.MOrientation.y;
                targetPosition.MOrientation.z = playerrot.MOrientation.z;
                targetPosition.MAngle = playerrot.MAngle;
                }
            player.setTransform(targetPosition);
            Point3F playervelocity = player.getVelocity();
            playervelocity = playervelocity.vectorScale(exit["exitVelocityScale"].AsFloat());
            player.setVelocity(playervelocity);
            // Prevent the object from doing an immediate second teleport
            // In the case of a bidirectional teleporter
            player["isTeleporting"] = true.AsString();
            }
        }
    }