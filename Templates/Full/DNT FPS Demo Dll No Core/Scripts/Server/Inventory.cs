// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    public partial class Main : TorqueScriptTemplate
        {
        [Torque_Decorations.TorqueCallBack("", "", "serverCmdUse", "(%client, %data)", 2, 1200, false)]
        public void ServerCmdUse(coGameConnection client, coItem data)
            {
            if (((coPlayer)client.getControlObject()).isObject())
                ((coPlayer)client.getControlObject()).call("use", data);

            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "use", "(%this, %data)", 2, 1200, false)]
        public bool ShapeBaseShapeBaseUse(coShapeBase thisobj, coItemData data)
            {

            coGameConnection client = thisobj.getControllingClient();
            if (client.isObject())
                {
                double defaultfov = client.getControlCameraDefaultFov();
                double fov = client.getControlCameraFov();
                if (defaultfov != fov)
                    return false;
                }



            if (ShapeBaseShapeBaseGetInventory(thisobj, data) > 0)
                return data.call("onUse", thisobj).AsBool();

            return false;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "throw", "(%this, %data,%amount)", 3, 1200, false)]
        public bool ShapeBaseShapeBaseThrow(coShapeBase thisobj, coItemData data, int amount = 1)
            {
            bool functionresult = false;
            if (ShapeBaseShapeBaseGetInventory(thisobj, data) > 0)
                {
                coSimObject objectid = data.call("onThrow", thisobj, amount.AsString());
                    {
                    if (objectid != 0)
                        {
                        thisobj.call("throwObject", objectid);
                        AudioServerPlay3D("ThrowSnd", thisobj.getTransform());
                        functionresult = true;
                        }
                    }
                }
            return functionresult;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "pickup", "(%this, %data,%amount)", 3, 1200, false)]
        public bool ShapeBaseShapeBasePickup(coShapeBase thisobj, coItem obj, int amount)
            {
            coItemData data = obj.getDataBlock();

            if (amount == 0)
                {
                int maxamount = ShapeBaseShapeBaseMaxInventory(thisobj, data);

                int curamount = ShapeBaseShapeBaseGetInventory(thisobj, data);

                amount = (maxamount - curamount);
                }

            if (amount > 0)
                return data.call("onPickUp", obj, thisobj, amount.AsString()).AsBool();

            return false;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "hasInventory", "(%this, %data)", 2, 1200, false)]
        public bool ShapeBaseShapeBaseHasInventory(coShapeBase thisobj, coItemData data)
            {
            int amount = thisobj["inv[" + data.getName() + "]"].AsInt();
            return amount > 0;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "hasAmmo", "(%this, %data)", 2, 1200, false)]
        public bool ShapeBaseShapeBaseHasAmmo(coShapeBase thisob, coItem weapon)
            {
            coItemData weaponimageammo = weapon["image.ammo"];
            if (weaponimageammo == "")
                return true;
            return ShapeBaseShapeBaseGetInventory(thisob, weaponimageammo) > 0;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "maxInventory", "(%this, %data)", 2, 1200, false)]
        public int ShapeBaseShapeBaseMaxInventory(coShapeBase thisobj, coItemData data)
            {
            if (data.isField("clip"))
                return data["maxInventory"].AsInt();

            return (( coSimDataBlock)thisobj.getDataBlock())["maxInv[" + data.getName() + "]"].AsInt();
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "incInventory", "(%this, %data,%amount)", 3, 1200, false)]
        public int ShapeBaseShapeBaseIncInventory(coShapeBase player, coItemData datablock, int amount)
            {
            int maxamount = ShapeBaseShapeBaseMaxInventory(player, datablock);

            int total = player["inv[" + datablock.getName() + "]"].AsInt();

            if (total < maxamount)
                {
                if (total + amount > maxamount)
                    {
                    amount = (maxamount - total);
                    }
                ShapeBaseShapeBaseSetInventory(player, datablock, (total + amount));
                return amount;
                }
            return 0;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "setInventory", "(%this, %data,%value)", 3, 1200, false)]
        public int ShapeBaseShapeBaseSetInventory(coShapeBase thisobj, coItemData data, int value = 0)
            {
            if (thisobj == "")
                return 0;
            int max = 0;


            max = ShapeBaseShapeBaseMaxInventory(thisobj, data);
            if (value > max)
                value = max;

            int amount = thisobj["inv[" + data.getName() + "]"].AsInt();


            if (amount != value)
                {
                thisobj["inv[" + data.getName() + "]"] = value.AsString();


                if (console.isMethodInNamespace(data, "onInventory"))
                    data.call("onInventory", thisobj, value.AsString());

                //string datablock = console.getDatablock(thisobj).AsString();

                if (console.isObject((( coSimDataBlock)thisobj.getDataBlock())) && console.isMethodInNamespace((( coSimDataBlock)thisobj.getDataBlock()), "onInventory"))
                    (( coSimDataBlock)thisobj.getDataBlock()).call("onInventory", data, value.AsString());
                }
            return value;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "decInventory", "(%this, %data,%value)", 3, 1200, false)]
        public int ShapeBaseShapeBaseDecInventory(coShapeBase shapebase, coItemData data, int amount = 0)
            {
            int total = shapebase["inv[" + data.getName() + "]"].AsInt();


            if (total > 0)
                {
                if (total < amount)
                    amount = total;

                ShapeBaseShapeBaseSetInventory(shapebase, data, (total - amount));
                return amount;
                }
            return 0;
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "onInventory", "(%this, %data, %value)", 3, 1200, false)]
        public string ShapeBaseShapeBaseOnInventory(coShapeBase thisobj, coItem data, string value)
            {
            // Invoked on ShapeBase objects whenever their inventory changes
            // for the given datablock.
            return "0";
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBaseData", "onUse", "(%this, %user)", 2, 1200, false)]
        public string ShapeBaseDataShapeBaseDataOnUse(coShapeBaseData thisobj, coPlayer user)
            {
            //// Invoked when the object uses this datablock, should return
            //// true if the item was used.
            return "0";
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBaseData", "onThrow", "(%this, %user, %amount)", 3, 1200, false)]
        public string ShapeBaseDataShapeBaseDataOnThrow(coShapeBaseData thisobj, coPlayer user, int amount)
            {
            // Invoked when the object is thrown.  This method should
            // construct and return the actual mission object to be
            // physically thrown.  This method is also responsible for
            // decrementing the user's inventory.
            return "0";
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBaseData", "onPickup", "(%this, %obj, %user, %amount)", 4, 1200, false)]
        public string ShapeBaseDataShapeBaseDataOnPickup(coShapeBaseData thisobj, coItem obj, coPlayer user, int amount)
            {
            // Invoked when the user attempts to pickup this datablock object.
            // The %amount argument is the space in the user's inventory for
            // this type of datablock.  This method is responsible for
            // incrementing the user's inventory is something is addded.
            // Should return true if something was added to the inventory.
            return "0";
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBaseData", "onInventory", "(%this, %obj, %value)", 3, 1200, false)]
        public string ShapeBaseDataShapeBaseDataOnInventory(string coShapeBaseData, coPlayer user, int value)
            {
            return "0";
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "clearInventory", "(%this)", 1, 1200, false)]
        public void ShapeBaseShapeBaseClearInventory(coShapeBase thisobj)
            {
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "throwObject", "(%this, %obj)", 2, 1200, false)]
        public void ShapeBaseShapeBaseThrowObject(coShapeBase thisobj, coItem obj)
            {
            // Throw the given object in the direction the shape is looking.
            // The force value is hardcoded according to the current default
            // object mass and mission gravity (20m/s^2).

            float throwforce = (( coSimDataBlock)thisobj.getDataBlock())["throwForce"].AsFloat();
            if (throwforce == 0)
                throwforce = 20;

            // Start with the shape's eye vector...

            Point3F eye = thisobj.getEyeVector();
            Point3F vec = eye.vectorScale(throwforce);

            // Add a vertical component to give the object a better arc
            double verticalForce = throwforce / 2.0;
            float dot = Point3F.vectorDot(new Point3F("0 0 1"), eye);
            if (dot < 0)
                dot = dot * -1;

            vec = vec + Point3F.vectorScale(new Point3F(string.Format("0 0 {0}", verticalForce)), 1 - dot);
            vec = vec + thisobj.getVelocity();

            // Set the object's position and initial velocity
            TransformF pos = new TransformF(Util.getBoxCenter(thisobj.getWorldBox()));

            obj.setTransform(pos);

            obj.applyImpulse(pos.MPosition, vec);

            // Since the object is thrown from the center of the shape,
            // the object needs to avoid colliding with it's thrower.

            obj.setCollisionTimeout(thisobj);


            if ((obj.getClassName() != "AITurretShape") && (obj.getClassName() != "ProximityMine"))

                obj.schedule(ItemPopTime.AsString(), "delete");
            }

        [Torque_Decorations.TorqueCallBack("", "ShapeBase", "getInventory", "(%this, %data)", 2, 1200, false)]
        public int ShapeBaseShapeBaseGetInventory(coShapeBase thisobj, coItemData data)
            {
            return thisobj.isObject() ? thisobj["inv[" + data.getName() + "]"].AsInt() : 0;
            }
        }
    }