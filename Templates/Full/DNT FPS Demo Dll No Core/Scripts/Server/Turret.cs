// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    public partial class Main : TorqueScriptTemplate
        {
        [Torque_Decorations.TorqueCallBack("", "", "cs_init_TurretShapeData_vars", "", 0, 2900, true)]
        public void TurretShapeDataCsInitVars()
            {
            iGlobal["$TurretShape::RespawnTime"] = (30 * 1000);
            iGlobal["$TurretShape::DestroyedFadeDelay"] = 5 * 1000;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onAdd", "(%this, %obj)", 2, 2900, false)]
        public void TurretShapeData_OnAdd(coTurretShapeData thisobj, coShapeBase obj)
            {
            obj.setRechargeRate(thisobj["rechargeRate"].AsFloat());
            obj.setEnergyLevel(thisobj["MaxEnergy"].AsFloat());
            obj.setRepairRate(0);


            if (obj["mountable"] == "1" || obj["mountable"] == "")
                thisobj.call("isMountable", obj, true.AsString());
            else
                thisobj.call("isMountable", obj, false.AsString());

            if (thisobj["nameTag"] != "")
                obj.setShapeName(thisobj["nameTag"]);
            for (int i = 0; i < thisobj["numWeaponMountPoints"].AsInt(); i++)
                {
                ShapeBaseShapeBaseIncInventory(obj, thisobj["weapon[" + i + "]"], 1);

                coItemData weaponAmmo = thisobj["weaponAmmo[" + i + "]"];


                string weaponAmmoAmount = thisobj["weaponAmmoAmount[" + i + "]"];
                ShapeBaseShapeBaseIncInventory(obj, weaponAmmo, weaponAmmoAmount.AsInt());


                bool startLoaded = thisobj["startLoaded"].AsBool();

                obj.mountImage(thisobj["weapon[" + i + "].Image"], i, startLoaded, "");
                obj.setImageGenericTrigger(i, 0, false);
                }
            if (thisobj["enterSequence"] != "")
                {
                obj["entranceThread"] = "0";
                int et = obj["entranceThread"].AsInt();
                string es = thisobj["enterSequence"];
                obj.playThread(et, es);
                obj.pauseThread(et);
                }
            else
                {
                obj["entranceThread"] = "-1";
                }
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onRemove", "(%this, %obj)", 2, 2900, false)]
        public void TurretShapeData_OnRemove(coTurretShapeData thisobj, coShapeBase obj)
            {
            for (int i = 0; i < thisobj["numMountPoints"].AsInt(); i++)
                {
                if (obj.getMountNodeObject(i) == 0)
                    continue;

                coPlayer passenger = obj.getMountNodeObject(i).AsString();


                ((coTurretShapeData)passenger.getDataBlock()).call("doDismount", true.AsString());
                }
            }

        [Torque_Decorations.TorqueCallBack("", "MissionGroup", "respawnTurret", "(%this, %datablock, %className, %transform, %static, %respawn)", 6, 2900, false)]
        public string MissionGroupRespawnTurret(coSimSet thisobj, coTurretShapeData datablock, coTurretShape classname, TransformF transform, bool isstatic, bool respawn)
            {
            Torque_Class_Helper turret = new Torque_Class_Helper(classname, "");
            turret.Props.Add("datablock", datablock);
            turret.Props.Add("static", isstatic.AsString());
            turret.Props.Add("respawn", respawn.AsString());
            coTurretShape turretid = turret.Create();

            turretid.setTransform(transform);
            ((coSimSet)"MissioinGroup").pushToBack(turretid);
            return turretid;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "damage", "(%this, %turret, %sourceObject, %position, %damage, %damageType)", 6, 2900, false)]
        private void TurretShapeData_damage(coTurretShapeData thisobj, coTurretShape turret, TransformF position, coShapeBase sourceobject, float damage, string datatype)
            {
            if (turret.getDamageState() == "Dead")
                return;

            turret.applyDamage(damage);

            // Update the numerical Health HUD
            coShapeBase mountedobject = turret.getObjectMount();

            //if (mountedobject != 0)
            //    console.Call(mountedobject, "updateHealth");
            if (turret.getState() != "Dead")
                return;

            for (int i = 0; i < thisobj["numMountPoints"].AsInt(); i++)
                {
                coShapeBase player = turret.getMountNodeObject(i);
                if (player != 0)
                    console.Call(player, "killWithSource", new[] { "sourceobject", "InsideTurret" });
                }
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onDamage", "%this, %obj, %delta", 3, 2900, false)]
        private void TurretShapeData_onDamage(coTurretShapeData thisobj, coTurretShape obj, float delta)
            {
            // This method is invoked by the ShapeBase code whenever the
            // object's damage level changes.
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onDestroyed", "(%this, %obj, %lastState)", 3, 2900, false)]
        public void TurretShapeDataOnDestroy(coTurretShapeData thisobj, coTurretShape obj, string laststate)
            {
            // This method is invoked by the ShapeBase code whenever the
            // object's damage state changes.

            // Fade out the destroyed object.  Then schedule a return.
            int destroydelay = iGlobal["$TurretShape::DestroyedFadeDelay"];
            obj.startFade(1000, destroydelay, true);

            obj.schedule((destroydelay + 1000).AsString(), "delete");

            if (obj.call("doRespawn") != "")
                ((coSimSet)"MissionGroup").schedule(sGlobal["$TurretShape::RespawnTime"], "respawnTurret", thisobj, console.GetClassName(obj), obj.getTransform().AsString(), true.AsString(), true.AsString());
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onDisabled", "(%this, %obj, %lastState)", 3, 2900, false)]
        public void TurrestShapeDataOnDisable(coTurretShapeData thisobj, coTurretShape obj, string laststate)
            {
            // This method is invoked by the ShapeBase code whenever the
            // object's damage state changes.
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onEnabled", "(%this, %obj, %lastState)", 3, 2900, false)]
        public void TurrestShapeDataOnEnable(coTurretShapeData thisobj, coTurretShape obj, string laststate)
            {
            // This method is invoked by the ShapeBase code whenever the
            // object's damage state changes.
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "isMountable", "(%this, %obj, %val)", 3, 2900, false)]
        public void TurretShapeDataIsMountable(coTurretShapeData thisobj, coTurretShape obj, string val)
            {
            obj["mountable"] = val;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onMountObject", "(%this, %turret, %player, %node)", 4, 2900, false)]
        public void TurretShapeDataOnMountObject(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player, int node)
            {
            if (turret["entranceThread"].AsInt() < 0)
                return;

            int et = turret["entranceThread"].AsInt();

            turret.setThreadDir(et, false);
            turret.setThreadPosition(et, 0);
            turret.playThread(et, "");
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onUnmountObject", "(%this, %turret, %player)", 3, 2900, false)]
        public void TurretShapeDataOnUnmountObject(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player)
            {
            if (turret["entranceThread"].AsInt() < 0)
                return;

            int et = turret["entranceThread"].AsInt();

            // Play the entrance thread backwards for an exit

            turret.setThreadDir(et, false);
            turret.setThreadPosition(et, (float)1.0);
            turret.playThread(et, "");
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "mountPlayer", "(%this, %turret, %player)", 3, 2900, false)]
        public void TurretShapeDataMountPlayer(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player)
            {
            if (turret.isObject() && turret.getDamageState() != "Destroyed")
                turret.call("setMountTurret", player);
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "setMountTurret", "(%this, %turret, %player)", 3, 2900, false)]
        public void TurretShapeDataSetMountTurret(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player)
            {
            if (!turret.isObject() || turret.getDamageState() == "Destroyed")
                return;
            int node = thisobj.call("findEmptySeat", turret, player).AsInt();
            if (node < 0)
                return;
            turret.mountObject(player, node, new TransformF("0 0 0"));

            player["mVehicle"] = turret;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "findEmptySeat", "(%this, %turret, %player)", 3, 2900, false)]
        public int TurrestshapeDataFindEmptySeat(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player)
            {
            for (int i = 0; i < thisobj["numMountPoints"].AsInt(); i++)
                {
                int node = turret.getMountNodeObject(i);
                if (node == 0)
                    return i;
                }
            return -1;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "switchSeats", "(%this, %turret, %player)", 3, 2900, false)]
        public int TurrestShapeDataSwitchSeats(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player)
            {
            for (int i = 0; i < thisobj["numMountPoints"].AsInt(); i++)
                {
                int node = turret.getMountNodeObject(i);
                if (node == player || node != 0)
                    continue;
                if (node == 0)
                    return i;
                }
            return -1;
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onMount", "(%this, %turret, %player, %node)", 4, 2900, false)]
        public void TurretShapeDataOnMount(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player, int node)
            {
            ((coGameConnection)player["client"]).call("RefreshVehicleHud", turret, thisobj["reticle"], thisobj["zoomReticle"]);
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShapeData", "onUnmount", "(%this, %turret, %player, %node)", 4, 2900, false)]
        public void TurretShapeDataOnUnmount(coTurretShapeData thisobj, coTurretShape turret, coShapeBase player, int node)
            {
            player.call("RefreshVehicleHud", "0", "", "");
            }

        [Torque_Decorations.TorqueCallBack("", "TurretShape", "damage", "(%this, %sourceObject, %position, %damage, %damageType)", 5, 2900, false)]
        public void TurretShapeDataDamage(coTurretShape thisobj, coShapeBase sourceObject, TransformF position, float damage, string damagetype)
            {
            ((coTurretShapeData)(thisobj.getDataBlock())).call("damage", thisobj, position.AsString(), sourceObject, damage.AsString(), damagetype);
            }

        [Torque_Decorations.TorqueCallBack("", "", "sendMsgClientKilled_TurretDamage", "( %msgType, %client, %sourceClient, %damLoc )", 4, 2900, false)]
        public void SendMsgClientKilledTurretDamage(string msgtype, coGameConnection client, coShapeBase sourceclient, string damloc)
            {
            if (sourceclient == 0)
                MessageAll(msgtype, "%1 was shot down by a turret!", client["playerName"] + ");");
            else if (sourceclient == client)
                MessageAll(msgtype, "%1 kill by his own turret!", client["playerName"] + ");");
            else
                MessageAll(msgtype, "%1 was killed by a turret of %2!", client["playerName"] + ");", sourceclient["playerName"]);
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "onAdd", "(%this, %obj,nameSpaceDepth)", 3, 2900, false)]
        public void AiTurretShapeDataOnAdd(coAITurretShapeData thisobj, coAITurretShape obj, string nameSpaceDepth)
            {
            int nsd = (nameSpaceDepth.AsInt() + 1);
            console.ParentExecute(thisobj, "onAdd", nsd, new string[] { thisobj, obj });
            obj["mountable"] = false.AsString();
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "onThrow", "(%this, %user, %amount)", 3, 2900, false)]
        public string AiTurretShapeDataOnThrow(coAITurretShapeData thisobj, coPlayer user, int amount)
            {
            if (amount == 0)
                amount = 1;

            if (thisobj["maxInventory"] != "")
                if (amount > thisobj["maxInventory"].AsInt())
                    amount = thisobj["maxInventory"].AsInt();

            if (amount == 0)
                return "0";

            ShapeBaseShapeBaseDecInventory(user, thisobj, amount);
            //console.Call(user, "decInventory", new[] {thisobj, amount});
            TransformF rot = new TransformF(user.getEulerRotation());

            Torque_Class_Helper tc_obj = new Torque_Class_Helper("AITurretShape", "");
            tc_obj.Props.Add("datablock", thisobj);
            tc_obj.Props.Add("rotation", string.Format("{0}0 0 1 {1}{0}", '"', rot.MPosition.z));
            tc_obj.Props.Add("count", "1");
            tc_obj.Props.Add("sourceObject", user);
            tc_obj.Props.Add("client", console.GetVarString(string.Format("{0}.client", user)));
            tc_obj.Props.Add("isAiControlled", "1");

            coAITurretShape obj = tc_obj.Create();
            ((coSimSet)"MissionGroup").pushToBack(obj);
            obj.call("addToIgnoreList", user);


            coGameConnection client = user["client"];
            if (client.isObject())
                {
                if (client["ownedTurrets"] == "")
                    client["ownedTurrets"] = new Torque_Class_Helper("SimSet", "").Create().AsString();

                coSimSet SimSet_id = client["ownedTurrets"];
                int countofitems = SimSet_id.getCount();
                for (uint i = 0; i < countofitems; i++)
                    {
                    coAITurretShape turret = SimSet_id.getObject(i);
                    turret.call("addToIgnoreList", obj);
                    obj.call("addToIgnoreList", turret);
                    }
                SimSet_id.pushToBack(obj);
                }

            return obj;
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "onDestroyed", "(%this, %turret, %lastState,nameSpaceDepth)", 4, 2900, false)]
        public void AiTurretShapeData(coAITurretShapeData thisobj, coAITurretShape turret, string lastState, string nameSpaceDepth)
            {
            turret.playAudio(0, "TurretDestroyed");
            turret.setAllGunsFiring(false);
            turret.resetTarget();
            turret.setTurretState("Destroyed", false);


            for (int i = 0; i < thisobj["numWeaponMountPoints"].AsInt(); i++)
                turret.setImageGenericTrigger(i, 0, true);

            int nsd = (nameSpaceDepth.AsInt());
            console.ParentExecute(thisobj, "onDestroyed", nsd, new string[] { thisobj, turret, lastState });
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnScanning", "(%this, %turret)", 2, 2900, false)]
        public void AiTurretShapeDataOnScanning(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            turret.call("startScanForTargets");
            turret.playAudio(0, "TurretScanningSound");
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnTarget", "(%this, %turret)", 2, 2900, false)]
        public void AITurretShapeData_OnTarget(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            turret.call("startTrackingTarget");
            turret.playAudio(0, "TargetAquiredSound");
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnNoTarget", "(%this, %turret)", 2, 2900, false)]
        public void AITurretShapeData_OnNoTarget(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            turret.setAllGunsFiring(false);
            turret.recenterTurret();
            turret.playAudio(0, "TargetLostSound");
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnFiring", "(%this, %turret)", 2, 2900, false)]
        public void AITurretShapeData_OnFiring(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            turret.setAllGunsFiring(true);
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnThrown", "(%this, %turret)", 2, 2900, false)]
        public void AiTurretShapeDataOnThrown(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            turret.playAudio(0, "TurretThrown");
            }

        [Torque_Decorations.TorqueCallBack("", "AITurretShapeData", "OnDeploy", "(%this, %turret)", 2, 2900, false)]
        public void AITurretShapeData_OnDeploy(coAITurretShapeData thisobj, coAITurretShape turret)
            {
            for (int i = 0; i < thisobj["numWeaponMountPoints"].AsInt(); i++)
                turret.setImageLoaded(i, true);

            turret.playAudio(0, "TurretActivatedSound");
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeapon", "onUse", "(%this, %obj)", 2, 2900, false)]
        public void DeployableTurretWeaponOnUse(coAITurretShapeData thisobj, coAITurretShape obj)
            {
            console.Call_Classname("Weapon", "onUse", new string[] { thisobj, obj });
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeapon", "onPickup", "(%this, %obj)", 4, 2900, false)]
        public void DeployableTurretWeaponOnPickup(coAITurretShapeData thisobj, coAITurretShape obj, string shape, string amount)
            {
            console.Call_Classname("Weapon", "onPickup", new string[] { thisobj, obj, shape, amount });
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeapon", "onInventory", "(%this, %obj, %amount)", 3, 2900, false)]
        public void DeployableTurretWeaponOnInventory(coAITurretShapeData thisobj, coPlayer obj, int amount)
            {
            if (obj["client"] != "0" && obj["isAiControlled"].AsBool() == false)
                GameConnectionSetAmmoAmountHud(obj["client"], 1, amount);


            //Sometimes....  Alice to the moon.
            /*
             * So here I was thinking that this line of code in the torque script...
             *    if ( !%amount && ( %slot = %obj.getMountSlot( %this.image ) ) != -1 )
             *    was checking to see if the slot was != to -1... but that is not the case.
             *    What it is actually checking is if %slot is blank or not.  As in is the temporary 
             *    variable %slot a variable or not, (i.e. it's id is -1)
             *    
             * It's nice how they use error suppression in there tokens to hide
             * the error message that the function doesn't exist from the console.
             * But... really?  I mean, you couldn't comment that that was what the fuck you
             * where doing??????
             *    
             * Well shit, I do believe there could be an easier way.....
             */
            //error("Amount = " + amount);
            if (amount == 0 && obj.isMethod("getMountSlot"))
                obj.call("cycleWeapon", new[] { "prev" });
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeaponImage", "onMount", "(%this, %obj, %slot)", 3, 2900, false)]
        public void DeployableTurretWeaponImageOnMount(coShapeBaseImageData thisobj, coShapeBase obj, int slot)
            {
            obj.setImageAmmo(slot, true);

            int numTurrets = ShapeBaseShapeBaseGetInventory(obj, thisobj["item"]);

            if (obj["client"] != "" && obj["isAiControlled"].AsBool() == false)
                ((coGameConnection)obj["client"]).call("RefreshWeaponHud", "1", thisobj["item.previewImage"], thisobj["item.reticle"], thisobj["item.zoomReticle"], numTurrets.AsString());
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeaponImage", "onUnmount", "(%this, %obj, %slot)", 3, 2900, false)]
        public void DeployableTurretWeaponImageOnUnmount(coShapeBaseImageData thisobj, coShapeBase obj, int slot)
            {
            //print("AI CONTROL 7");
            if (obj["client"] != "" && obj["isAiControlled"].AsBool() == false)
                ((coGameConnection)obj["client"]).call("RefreshWeaponHud", "0");
            }

        [Torque_Decorations.TorqueCallBack("", "DeployableTurretWeaponImage", "onFire", "(%this, %obj, %slot)", 3, 2900, false)]
        public void DeployableTurretWeaponImageOnFire(coShapeBaseImageData thisobj, coShapeBase obj, int slot)
            {
            obj.schedule("0", "throw", thisobj["item"]);
            }
        }
    }