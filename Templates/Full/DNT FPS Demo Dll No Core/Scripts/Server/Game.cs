// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.Linq;
using WinterLeaf;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Scripts.Server
    {
    public partial class Main : TorqueScriptTemplate
        {
        public const string Game__DefaultPlayerClass = "Player";

        public const string Game__DefaultPlayerDataBlock = "DefaultPlayerData";

        public const string Game__DefaultPlayerSpawnGroups = "PlayerSpawnPoints PlayerDropPoints";

        public const string Game__DefaultCameraClass = "Camera";

        public const string Game__DefaultCameraDataBlock = "Observer";

        public const string Game__DefaultCameraSpawnGroups = "CameraSpawnPoints PlayerSpawnPoints PlayerDropPoints";

        public bool Game_Running;


        public bool isScriptFileThenRun(string filename)
            {
            if (console.Call("isScriptFile", new[] { filename }).AsBool())
                {
                Util.exec(filename, false, false);
                return true;
                }
            return false;
            }

        [Torque_Decorations.TorqueCallBack("", "", "onServerCreated", "", 0, 51, false)]
        public void onServerCreated()
            {
            sGlobal["$Server::GameType"] = sGlobal["$appName"];
            sGlobal["$Server::MissionType"] = "Deathmatch";
            iGlobal["$Game::StartTime"] = 0;

            Util._physicsInitWorld("server");


            isScriptFileThenRun("art/shapes/particles/managedParticleData.cs");
            isScriptFileThenRun("art/decals/managedDecalData.cs");
            isScriptFileThenRun("art/datablocks/managedDatablocks.cs");
            isScriptFileThenRun("art/forest/managedItemData.cs");
            isScriptFileThenRun("art/datablocks/datablockExec.cs");
            sGlobal["$Game::StartTime"] = sGlobal["$Sim::Time"];
            dnt.DoScriptInjection(ScriptType.Server, 100, 3100);
            }

        [Torque_Decorations.TorqueCallBack("", "", "onServerDestroyed", "", 0, 51, false)]
        public void onServerDestroyed()
            {
            Util._physicsDestroyWorld("server");
            }

        [Torque_Decorations.TorqueCallBack("", "", "onMissionLoaded", "", 0, 51, false)]
        public void onMissionLoaded()
            {
            Util._physicsStopSimulation("server");

            Game_Running = false;

            startGame();
            }


        [Torque_Decorations.TorqueCallBack("", "", "startGame", "", 0, 51, false)]
        public void startGame()
            {
            if (Game_Running)
                {
                console.error("startGame: End the game first!");
                return;
                }


            foreach (coGameConnection client in ClientGroup)
                {
                console.commandToClient(client, "GameStart");
                client["score"] = "0";
                client["kills"] = "0";
                client["deaths"] = "0";
                }

            Game_Running = true;
            }


        // ============================================================================  
        //  Client Management  
        // ============================================================================  

        // ----------------------------------------------------------------------------  
        // GameConnection Methods  
        // ----------------------------------------------------------------------------  
        // GameConnection manages the communication between the server's world and the  
        // client's simulation. These functions are responsible for maintaining the  
        // client's camera and player objects.  

        // These methods are extensions to the GameConnection class. Extending  
        // GameConnection makes it easier to deal with some of this functionality,  
        // but these could also be implemented as stand-alone functions.  
        //-----------------------------------------------------------------------------  


        //-----------------------------------------------------------------------------  
        // This is the main entry point for spawning a control object for the client.  
        // The control object is the actual game object that the client is responsible  
        // for controlling in the client and server simulations. We also spawn a  
        // convenient camera object for use as an alternate control object. We do not  
        // have to spawn this camera object in order to function in the simulation. 
        [Torque_Decorations.TorqueCallBack("", "GameConnection", "spawnCamera", "(%this, %spawnPoint)", 2, 51, false)]
        public void GameConnectionSpawnCamera(coGameConnection client, string spawnPoint)
            {
            coCamera camera = client["camera"];

            //string camera = console.GetVarString(thisobj + ".camera");

            // Set the control object to the default camera
            if (!camera.isObject())
                {
                camera = Util._spawnObject(Game__DefaultCameraClass, Game__DefaultCameraDataBlock);
                client["camera"] = camera;
                }

            // If we have a camera then set up some properties
            if (!camera.isObject())
                return;

            ((coSimSet)"MissionCleanup").pushToBack(camera);

            camera.scopeToClient(client);

            client.setControlObject(camera);

            if (spawnPoint == "")
                return;

            // Attempt to treat %spawnPoint as an object


            if (Util.getWordCount(spawnPoint) == 1 && console.isObject(spawnPoint))
                camera.setTransform(((coMarker)spawnPoint).getTransform());
            else
                camera.setTransform(new TransformF(spawnPoint));
            }


        [Torque_Decorations.TorqueCallBack("", "GameConnection", "onClientEnterGame", "%client", 1, 51, false)]
        public void GameConnectionOnClientEnterGame(coGameConnection client)
            {
            // Sync the client's clocks to the server's

            double simtime = dGlobal["$Sim::Time"];

            double starttime = dGlobal["$Game::StartTime"];

            double result = simtime - starttime;

            console.commandToClient(client, "SyncClock", new[] { result.AsString() });

            // Find a spawn point for the camera
            // This function currently relies on some helper functions defined in
            // core/scripts/server/spawn.cs. For custom spawn behaviors one can either
            // override the properties on the SpawnSphere's or directly override the
            // functions themselves.
            string cameraSpawnPoint = PickCameraSpawnPoint(Game__DefaultCameraSpawnGroups); //console.GetVarString("$Game::DefaultCameraSpawnGroups"));
            //%cameraSpawnPoint = pickCameraSpawnPoint($Game::DefaultCameraSpawnGroups);
            // Spawn a camera for this client using the found %spawnPoint

            GameConnectionSpawnCamera(client, cameraSpawnPoint);


            // Setup game parameters, the onConnect method currently starts
            // everyone with a 0 score.

            client["score"] = "0";
            client["kills"] = "0";
            client["deaths"] = "0";

            // weaponHUD

            GameConnectionRefreshWeaponHud(client, 0, "", "", "", 0);

            // Prepare the player object.

            GameConnectiOnPreparePlayer(client);

            MessageClient(client, "MsgClientJoin", "Current Players: " + ClientGroup.Count);

            // Inform the client we've joined up
            MessageClient(client, "MsgClientJoin", @"\c2Welcome to the Torque demo app %1.", console.GetVarString(client + ".playerName"), client, console.GetVarString(client + ".sendGuid"), console.GetVarString(client + ".team"), console.GetVarString(client + ".score"), console.GetVarString(client + ".kills"), console.GetVarString(client + ".deaths"), console.GetVarString(client + ".isAiControlled"), console.GetVarString(client + ".isAdmin"), console.GetVarString(client + ".isSuperAdmin"));

            //// Inform all the other clients of the new guy

            MessageAllExcept(client, "-1", "MsgClientJoin", @"\c1%1 joined the game.", console.GetVarString(client + ".playerName"), client, console.GetVarString(client + ".sendGuid"), console.GetVarString(client + ".team"), console.GetVarString(client + ".score"), console.GetVarString(client + ".kills"), console.GetVarString(client + ".deaths"), console.GetVarString(client + ".isAiControlled"), console.GetVarString(client + ".isAdmin"), console.GetVarString(client + ".isSuperAdmin"));
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "preparePlayer", "%client", 1, 51, false)]
        public void GameConnectiOnPreparePlayer(coGameConnection client)
            {
            string playerSpawnPoint = PickPlayerSpawnPoint(Game__DefaultPlayerSpawnGroups);

            if (SpawnPlayer(client, playerSpawnPoint, false))

                GameConnectionLoadOut(client, client["player"]);
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "onClientLeaveGame", "%client", 1, 51, false)]
        public void GameConnectionOnClientLeaveGame(coGameConnection client)
            {

            if (((coCamera)client["camera"]).isObject())
                ((coCamera)client["camera"]).delete();


            if (((coPlayer)client["player"]).isObject())
                ((coPlayer)client["player"]).delete();

            }


        // ----------------------------------------------------------------------------  
        //  Functions that implement game-play  
        // ----------------------------------------------------------------------------  

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "loadOut", "%client,%player", 2, 51, false)]
        public void GameConnectionLoadOut(coGameConnection client, coPlayer player)
            {
            ShapeBaseClearWeaponCycle(player);

            ShapeBaseShapeBaseSetInventory(player, "Ryder", 1);
            ShapeBaseShapeBaseSetInventory(player, "RyderClip", ShapeBaseShapeBaseMaxInventory(player, "RyderClip"));
            ShapeBaseShapeBaseSetInventory(player, "RyderAmmo", ShapeBaseShapeBaseMaxInventory(player, "RyderAmmo"));

            ShapeBaseAddToWeaponCycle(player, "Ryder");


            ShapeBaseShapeBaseSetInventory(player, "Lurker", 1);
            ShapeBaseShapeBaseSetInventory(player, "LurkerClip", ShapeBaseShapeBaseMaxInventory(player, "LurkerClip"));
            ShapeBaseShapeBaseSetInventory(player, "LurkerAmmo", ShapeBaseShapeBaseMaxInventory(player, "LurkerAmmo"));

            ShapeBaseAddToWeaponCycle(player, "Lurker");

            ShapeBaseShapeBaseSetInventory(player, "LurkerGrenadeLauncher", 1);
            ShapeBaseShapeBaseSetInventory(player, "LurkerGrenadeAmmo", ShapeBaseShapeBaseMaxInventory(player, "LurkerGrenadeAmmo"));

            ShapeBaseAddToWeaponCycle(player, "LurkerGrenadeLauncher");

            ShapeBaseShapeBaseSetInventory(player, "ProxMine", ShapeBaseShapeBaseMaxInventory(player, "ProxMine"));

            ShapeBaseAddToWeaponCycle(player, "ProxMine");


            ShapeBaseShapeBaseSetInventory(player, "DeployableTurret", ShapeBaseShapeBaseMaxInventory(player, "DeployableTurret"));
            ShapeBaseAddToWeaponCycle(player, "DeployableTurret");


            coSimDataBlock playerdatablock = player.getDataBlock();
            string junk = playerdatablock["mainWeapon.image"];

            if (junk == "")
                player.mountImage("LurkerWeaponImage", 0, true, "");
            else
                player.mountImage(junk, 0, true, "");

            //ShapeBase.mountImage(player, junk == "" ? junk : "LurkerWeaponImage", 0, true, "");
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "onLeaveMissionArea", "%client", 1, 51, false)]
        public void GameConnectionOnLeaveMissionArea(coGameConnection client)
            {
            MessageClient(client, "MsgClientJoin", console.ColorEncode(@"\c2Now leaving the mission area!"));
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "onEnterMissionArea", "%client", 1, 51, false)]
        public void GameConnectionOnEnterMissionArea(coGameConnection client)
            {
            MessageClient(client, "MsgClientJoin", console.ColorEncode(@"\c2Now entering the mission area!"));
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "onDeath", "%client, %sourceObject, %sourceClient, %damageType, %damLoc", 5, 51, false)]
        public void GameConnectionOnDeath(coGameConnection client, coPlayer sourceobject, coGameConnection sourceclient, string damagetype, string damloc)
            {
            if (client.isObject())
                {
                if (client["ownedTurrets"] == "")
                    client["ownedTurrets"] = new Torque_Class_Helper("SimSet").Create().AsString();

                coSimSet simSet = client["ownedTurrets"];

                for (uint i = 0; i < simSet.getCount(); i++)
                    {
                    ((coSimObject)simSet.getObject(i)).schedule("10", "delete");
                    }
                }


            // clear the weaponHUD

            GameConnectionRefreshWeaponHud(client, 0, "", "", "", 0);

            coPlayer player = client["player"];

            // Clear out the name on the corpse
            player.setShapeName("");

            // Update the numerical Health HUD

            //PlayerUpdateHealth(player);


            // Switch the client over to the death cam and unhook the player object.
            coCamera camera = client["camera"];

            if (camera.isObject() && player.isObject())
                {
                camera.call("setMode", "Corpse", player, "", "");
                client.setControlObject(camera);
                }
            else
                {
                console.print("------------>Failed to Switch the client over to the death cam.");
                }

            client["player"] = "0";

            // Display damage appropriate kill message
            string sendMsgFunction = "sendMsgClientKilled_" + damagetype;
            if (!console.isFunction(sendMsgFunction))
                {
                sendMsgFunction = "sendMsgClientKilled_Default";
                }

            console.Call(sendMsgFunction, new string[] { "MsgClientKilled", client, sourceclient, damloc });
            // Dole out points and check for win
            if ((damagetype == "Suicide") || (sourceclient == client))
                {
                IncDeaths(client, "1", "1");
                IncScore(client, "-1", "0");
                }
            else
                {
                IncDeaths(client, "1", "0");
                IncScore(sourceclient, "1", "1");
                IncKills(sourceclient, "1", "0");
                }
            }


        [Torque_Decorations.TorqueCallBack("", "", "incKills", "(%client, %kill, %dontMessageAll)", 3, 51, false)]
        public void IncKills(coGameConnection client, string kill, string dontmessageall)
            {
            //if (!console.isObject(client)) return;
            //console.SetVar(client + ".kills", console.GetVarInt(client + ".kills") + int.Parse(kill));
            //if (dontmessageall == "0")
            //    MessageAll("MsgClientScoreChanged", "", console.GetVarString(client + ".score"),
            //               console.GetVarString(client + ".kills"), console.GetVarString(client  + "deaths"), client);
            }

        [Torque_Decorations.TorqueCallBack("", "", "incDeaths", "(%client, %kill, %dontMessageAll)", 3, 51, false)]
        public void IncDeaths(coGameConnection client, string death, string dontmessageall)
            {
            //if (!console.isObject(client)) return;
            //console.SetVar(string.Format("{0}.deaths", client), console.GetVarInt(string.Format("{0}.deaths", client)) + int.Parse(death));
            //if (dontmessageall == "0")
            //    MessageAll("MsgClientScoreChanged", "", console.GetVarString(client + ".score"),
            //               console.GetVarString(client + ".kills"), console.GetVarString(client + ".deaths"), client);
            }

        [Torque_Decorations.TorqueCallBack("", "", "incScore", "(%client, %kill, %dontMessageAll)", 3, 51, false)]
        public void IncScore(coGameConnection client, string score, string dontmessageall)
            {
            //if (!console.isObject(client)) return;
            //console.SetVar(client + ".score", console.GetVarInt(client + ".score") + int.Parse(score));
            //if (dontmessageall == "0")
            //    MessageAll("MsgClientScoreChanged", "", console.GetVarString(client + ".score"),
            //               console.GetVarString(client + "kills"), console.GetVarString(client + ".deaths"), client);
            }

        [Torque_Decorations.TorqueCallBack("", "", "getScore", "(%%client)", 1, 51, false)]
        public int GetScore(coGameConnection client)
            {
            return client["score"].AsInt();
            }

        [Torque_Decorations.TorqueCallBack("", "", "getKills", "(%%client)", 1, 51, false)]
        public int GetKills(coGameConnection client)
            {
            return client["kills"].AsInt();
            }

        [Torque_Decorations.TorqueCallBack("", "", "getDeaths", "(%%client)", 1, 51, false)]
        public int GetDeaths(coGameConnection client)
            {
            return client["deaths"].AsInt();
            }


        [Torque_Decorations.TorqueCallBack("", "GameConnection", "setAmmoAmountHud", "(%client, %amount, %amountInClips )", 3, 51, false)]
        public void GameConnectionSetAmmoAmountHud(coGameConnection client, int amount, int amountinClips)
            {
            if (console.isObject(client))
                console.commandToClient(client, "SetAmmoAmountHud", new[] { amount.AsString(), amountinClips.AsString() });
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "RefreshWeaponHud", "(%client, %amount, %preview, %ret, %zoomRet, %amountInClips)", 6, 51, false)]
        public void GameConnectionRefreshWeaponHud(coGameConnection client, int amount, string preview, string ret, string zoomRet, int amountInClips)
            {
            if (console.isObject(client))
                console.commandToClient(client, "RefreshWeaponHud", new[] { amount.AsString(), preview, ret, zoomRet, amountInClips.AsString() });
            }

        [Torque_Decorations.TorqueCallBack("", "", "sendMsgClientKilled_Impact", "(%msgType, %client, %sourceClient, %damLoc )", 4, 51, false)]
        public void SendMsgClientKilledImpact(string msgtype, coGameConnection client, string sourceclient, string damloc)
            {
            if (console.isObject(client))

                MessageAll(msgtype, "%1 fell to his death!", client["playerName"]); // console.GetVarString(string.Format("{0}.playerName", client)));
            }

        [Torque_Decorations.TorqueCallBack("", "", "sendMsgClientKilled_Suicide", "(%msgType, %client, %sourceClient, %damLoc )", 4, 51, false)]
        public void SendMsgClientKilledSuicide(string msgtype, coGameConnection client, string sourceclient, string damloc)
            {
            if (console.isObject(client))

                MessageAll(msgtype, "%1 takes his own life!", client["playerName"]);
            }

        [Torque_Decorations.TorqueCallBack("", "", "sendMsgClientKilled_Default", "(%msgType, %client, %sourceClient, %damLoc )", 4, 51, false)]
        public void SendMsgClientKilledDefault(string msgtype, coGameConnection client, coGameConnection sourceclient, string damloc)
            {
            if (console.isObject(client))
                {
                if (sourceclient == client)
                    SendMsgClientKilledSuicide(msgtype, client, sourceclient, damloc);

                else if (console.GetVarString(sourceclient["team"]) != "" && sourceclient["team"] != client["team"])
                    MessageAll(msgtype, "%1 killed by %2 - friendly fire!", client["playerName"], sourceclient["playerName"]);
                else
                    {
                    if (console.isObject(sourceclient))
                        MessageAll(msgtype, "%1 gets nailed by %2!", client["playerName"], sourceclient["playerName"]);
                    else
                        MessageAll(msgtype, "%1 gets nailed by %2!", client["playerName"], "a Bot!");
                    }
                }
            }

        [Torque_Decorations.TorqueCallBack("", "", "EditorIsActive", "()", 0, 51, false)]
        public bool EditorIsActive()
            {

            if (!((coGuiControl)"EditorGui").isObject())
                return false;

            return ((coGuiControl)"EditorGui") == ((coGuiCanvas)"canvas");

            }

        [Torque_Decorations.TorqueCallBack("", "", "GuiEditorIsActive", "()", 0, 51, false)]
        public bool GuiEditorIsActive()
            {
            if (!((coGuiControl)"GuiEditorGui").isObject())
                return false;

            return ((coGuiControl)"GuiEditorGui") == ((coGuiCanvas)"canvas");


            }


        [Torque_Decorations.TorqueCallBack("", "", "pickCameraSpawnPoint", "(%spawnGroups)", 1, 51, false)]
        public string PickCameraSpawnPoint(string spawnGroups)
            {
            coSimObject spawnpoint = null;
            String[] lspawngroups = spawnGroups.Split(' ');

            foreach (coSimSet group in lspawngroups)
                {
                if (!group.isObject())
                    continue;
                spawnpoint = group.getRandom();
                if (spawnpoint.isObject())
                    return spawnpoint;
                }
            coSpawnSphere DefaultCameraSpawnSphere = "DefaultCameraSpawnSphere";
            if (!DefaultCameraSpawnSphere.isObject())
                {
                Torque_Class_Helper spawn = new Torque_Class_Helper("SpawnSphere", "DefaultCameraSpawnSphere");
                spawn.Props.Add("dataBlock", "SpawnSphereMarker");
                spawn.PropsAddString("spawnClass", Game__DefaultCameraClass);
                spawn.PropsAddString("spawnDatablock", Game__DefaultCameraDataBlock);
                coSpawnSphere spawnobj = spawn.Create();

                ((coSimSet)"MissionCleanup").pushToBack(spawnobj);
                }

            return DefaultCameraSpawnSphere;
            }

        [Torque_Decorations.TorqueCallBack("", "", "pickPlayerSpawnPoint", "(%spawnGroups)", 1, 51, false)]
        public string PickPlayerSpawnPoint(string spawnGroups)
            {
            coSimObject spawnpoint = null;
            String[] lspawngroups = spawnGroups.Split(' ');


            foreach (coSimSet group in lspawngroups)
                {
                if (!group.isObject())
                    continue;
                spawnpoint = group.getRandom();
                if (spawnpoint.isObject())
                    return spawnpoint;
                }


            coSpawnSphere DefaultPlayerSpawnSphere = null;

            DefaultPlayerSpawnSphere = "DefaultPlayerSpawnSphere";

            if (DefaultPlayerSpawnSphere.isObject())
                {
                Torque_Class_Helper spawn = new Torque_Class_Helper("SpawnSphere", "DefaultPlayerSpawnSphere");
                spawn.Props.Add("dataBlock", "SpawnSphereMarker");
                spawn.PropsAddString("spawnClass", Game__DefaultPlayerClass);
                spawn.PropsAddString("spawnDatablock", Game__DefaultPlayerDataBlock);
                coSpawnSphere spawnid = spawn.Create();
                ((coSimSet)"MissionCleanup").pushToBack(spawnid);
                }

            return DefaultPlayerSpawnSphere;
            }

        [Torque_Decorations.TorqueCallBack("", "GameConnection", "spawnPlayer", "(%client, %spawnPoint, %noControl)", 3, 51, false)]
        public bool SpawnPlayer(coGameConnection client, string spawnpoint, bool nocontrol)
            {
            coPlayer player = client["player"];


            if (player.isObject())
                {
                console.error("Attempting to create a player for a client that already has one!");
                return false;
                }

            if ((spawnpoint.Split(' ').GetUpperBound(0) == 0) && (spawnpoint.isObject()))
                {
                // Attempt to treat %spawnPoint as an object
                string spawnclass = Game__DefaultPlayerClass;
                string spawndatablock = Game__DefaultPlayerDataBlock;

                coSimObject ospawnpoint = spawnpoint;


                // Overrides by the %spawnPoint
                if (ospawnpoint["spawnClass"] != "")
                    {
                    spawnclass = ospawnpoint["spawnClass"];
                    spawndatablock = ospawnpoint["spawnDataBlock"];
                    }

                else if (ospawnpoint["spawnDatablock"] != "")
                    {
                    // This may seem redundant given the above but it allows
                    // the SpawnSphere to override the datablock without
                    // overriding the default player class
                    spawndatablock = ospawnpoint["spawnDatablock"];
                    }
                string spawnproperties = ospawnpoint["spawnProperties"];
                string spawnScript = ospawnpoint["spawnScript"];

                // Spawn with the engine's Sim::spawnObject() function
                player = console.SpawnObject(spawnclass, spawndatablock, "", spawnproperties, spawnScript);
                // If we have an object do some initial setup
                if (console.isObject(player))
                    {
                    // Pick a location within the spawn sphere.
                    player.setTransform(PointInSpawnSphere(player, ((coSpawnSphere)spawnpoint)));
                    }
                else
                    {
                    // If we weren't able to create the player object then warn the user
                    // When the player clicks OK in one of these message boxes, we will fall through
                    // to the "if (!isObject(%player))" check below.
                    if (console.GetVarString(spawndatablock).Trim() != "")
                        {
                        console.Call("MessageBoxOK", new[] { "Spawn Player Failed", "Unable to create a player with class " + spawnclass + " and datablock " + spawndatablock + ".\n\nStarting as an Observer instead.", "" });
                        }
                    else
                        {
                        console.Call("MessageBoxOK", new[] { "Spawn Player Failed", "Unable to create a player with class " + spawnclass + ".\n\nStarting as an Observer instead.", "" });
                        }
                    }
                }
            else
                {
                // Create a default player
                player = console.SpawnObject(Game__DefaultPlayerClass, Game__DefaultPlayerDataBlock, "", "", "");

                if (player.isMemberOfClass("Player"))
                    //if (SimObject.SimObject_isMemberOfClass(player, "Player"))
                    console.warn("Trying to spawn a class that does not derive from player!!!!!");
                // Treat %spawnPoint as a transform
                player.setTransform(new TransformF(spawnpoint));
                }

            // Update the default camera to start with the player
            if (!console.isObject(player))
                {
                client["spawnCamera"] = spawnpoint;
                return false;
                }

            ((coSimSet)"MissionCleanup").pushToBack(player);
            // Update the default camera to start with the player


            // Store the client object on the player object for
            // future reference
            player["client"] = client;

            // If the player's client has some owned turrets, make sure we let them
            // know that we're a friend too.

            if (client["ownedTurrets"].AsInt() >= 1)
                {
                coSimSet turrets = client["ownedTurrets"];
                for (uint i = 0; i < turrets.getCount(); i++)
                    {
                    ((coTurretShape)turrets.getObject(i)).call("addToIgnoreList", player);
                    }
                }

            player.setShapeName(client["playerName"]);

            player.setEnergyLevel(((coPlayerData)player.getDataBlock())["maxEnergy"].AsFloat());

            if (client["skin"] != "")
                {
                string availableSkins = ((coPlayerData)player.getDataBlock())["availableSkins"];
                foreach (coGameConnection other in ClientGroup.Where(other => other != client))
                    {
                    availableSkins = availableSkins.Replace(console.GetVarString(other + ".skin"), " ");

                    availableSkins = availableSkins.Replace("  ", " ");
                    }
                List<string> availskin = availableSkins.Split('\t').ToList();
                if (availskin.Count > 0)
                    {
                    int r = new Random().Next(0, availskin.Count - 1);
                    client["skin"] = availskin[r];
                    }
                }

            player.setSkinName(client["skin"]);
            client["player"] = player;

            coSimObject control = null;
            if (console.GetVarString("$startWorldEditor") == "1")
                {
                control = client["camera"];
                console.Call("EditorGui", "syncCameraGui");
                }
            else
                control = player;

            if (!nocontrol)
                {
                client.setControlObject(control);
                }

            int team = new Random().Next(1, 2);
            AddObjectTo_MobSearchGroup(player, team);

            MessageClient(client, "System", "Your on Team " + team);

            console.error(DateTime.Now + " --- PLAYER JOIN::Name '" + Util.StripMLControlChars(player.getShapeName()) + "'::ID '" + player + "'");
            return true;
            }


        [Torque_Decorations.TorqueCallBack("", "", "pickPointInSpawnSphere", "(%objectToSpawn, %spawnSphere)", 2, 51, false)]
        public TransformF PointInSpawnSphere(coPlayer objectToSpawn, coSpawnSphere spawnSphere)
            {
            bool spawnLocationFound = false;
            int attemptsToSpawn = 0;

            TransformF spherLocationP3F = new TransformF();


            while (!spawnLocationFound && attemptsToSpawn < 5)
                {
                spherLocationP3F = spawnSphere.getTransform();

                Random r = new Random();

                float angleY = (float)tMath.mDegToRad((r.NextDouble() * 100) * tMath.M_2PI_F);
                float angleXZ = (float)tMath.mDegToRad((r.NextDouble() * 100) * tMath.M_2PI_F);

                int radius = spawnSphere["radius"].AsInt();
                spherLocationP3F.MPosition.x += (float)(Math.Cos(angleY) * Math.Sin(angleXZ) * (r.Next(radius * -1, radius)));
                spherLocationP3F.MPosition.y += (float)(Math.Cos(angleXZ) * (r.Next(radius * -1, radius)));
                spawnLocationFound = true;

                // Now have to check that another object doesn't already exist at this spot.
                // Use the bounding box of the object to check if where we are about to spawn in is
                // clear.


                TransformF boundingboxsize = new TransformF(((coSimDataBlock)objectToSpawn.getDataBlock())["boundingBox"]);
                float searchRadius = boundingboxsize.MPosition.x;
                float boxSizeY = boundingboxsize.MPosition.y;
                if (boxSizeY > searchRadius)
                    {
                    searchRadius = boxSizeY;
                    }
                List<UInt32> objectsfound = console.ContainerRadiusSearch(spherLocationP3F.MPosition, searchRadius, (UInt32)SceneObjectTypesAsUint.PlayerObjectType, false);
                if (objectsfound.Count > 0)
                    spawnLocationFound = false;

                attemptsToSpawn++;
                }
            if (!spawnLocationFound)
                {
                spherLocationP3F = spawnSphere.getTransform();
                console.warn("WARNING: Could not spawn player after 5 times");
                }
            return spherLocationP3F;
            }
        }
    }